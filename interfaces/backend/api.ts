/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * MangaDex API
 * MangaDex is an ad-free manga reader offering high-quality images!  This document details our API as it is right now. It is in no way a promise to never change it, although we will endeavour to publicly notify any major change.  # Acceptable use policy  Usage of our services implies acceptance of the following: - You **MUST** credit us - You **MUST** credit scanlation groups if you offer the ability to read chapters - You **CANNOT** run ads or paid services on your website and/or apps  These may change at any time for any and no reason and it is up to you check for updates from time to time.  # Security issues  If you believe you found a security issue in our API, please check our [security.txt](/security.txt) to get in touch privately.
 *
 * OpenAPI spec version: 5.9.0
 * Contact: support@mangadex.org
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as isomorphicFetch from 'isomorphic-fetch'
import { Configuration } from './configuration'

const BASE_PATH = 'https://api.mangadex.org'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|'
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface AccountActivateResponse
 */
export interface AccountActivateResponse {
  /**
   *
   * @type {string}
   * @memberof AccountActivateResponse
   */
  result?: AccountActivateResponse.ResultEnum
}

/**
 * @export
 * @namespace AccountActivateResponse
 */
export namespace AccountActivateResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok'
  }
}
/**
 *
 * @export
 * @interface Author
 */
export interface Author {
  /**
   *
   * @type {string}
   * @memberof Author
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Author
   */
  type?: Author.TypeEnum
  /**
   *
   * @type {AuthorAttributes}
   * @memberof Author
   */
  attributes?: AuthorAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof Author
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace Author
 */
export namespace Author {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Author = <any>'author'
  }
}
/**
 *
 * @export
 * @interface AuthorAttributes
 */
export interface AuthorAttributes {
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  imageUrl?: string
  /**
   *
   * @type {LocalizedString}
   * @memberof AuthorAttributes
   */
  biography?: LocalizedString
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  twitter?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  pixiv?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  melonBook?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  fanBox?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  booth?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  nicoVideo?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  skeb?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  fantia?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  tumblr?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  youtube?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  weibo?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  naver?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  website?: string
  /**
   *
   * @type {number}
   * @memberof AuthorAttributes
   */
  version?: number
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof AuthorAttributes
   */
  updatedAt?: string
}
/**
 *
 * @export
 * @interface AuthorCreate
 */
export interface AuthorCreate {
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  name: string
  /**
   *
   * @type {LocalizedString}
   * @memberof AuthorCreate
   */
  biography?: LocalizedString
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  twitter?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  pixiv?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  melonBook?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  fanBox?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  booth?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  nicoVideo?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  skeb?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  fantia?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  tumblr?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  youtube?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  weibo?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  naver?: string
  /**
   *
   * @type {string}
   * @memberof AuthorCreate
   */
  website?: string
  /**
   *
   * @type {number}
   * @memberof AuthorCreate
   */
  version?: number
}
/**
 *
 * @export
 * @interface AuthorEdit
 */
export interface AuthorEdit {
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  name?: string
  /**
   *
   * @type {LocalizedString}
   * @memberof AuthorEdit
   */
  biography?: LocalizedString
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  twitter?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  pixiv?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  melonBook?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  fanBox?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  booth?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  nicoVideo?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  skeb?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  fantia?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  tumblr?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  youtube?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  weibo?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  naver?: string
  /**
   *
   * @type {string}
   * @memberof AuthorEdit
   */
  website?: string
  /**
   *
   * @type {number}
   * @memberof AuthorEdit
   */
  version: number
}
/**
 *
 * @export
 * @interface AuthorList
 */
export interface AuthorList {
  /**
   *
   * @type {string}
   * @memberof AuthorList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof AuthorList
   */
  response?: string
  /**
   *
   * @type {Array<Author>}
   * @memberof AuthorList
   */
  data?: Array<Author>
  /**
   *
   * @type {number}
   * @memberof AuthorList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof AuthorList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof AuthorList
   */
  total?: number
}
/**
 *
 * @export
 * @interface AuthorResponse
 */
export interface AuthorResponse {
  /**
   *
   * @type {string}
   * @memberof AuthorResponse
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof AuthorResponse
   */
  response?: string
  /**
   *
   * @type {Author}
   * @memberof AuthorResponse
   */
  data?: Author
}
/**
 *
 * @export
 * @interface BeginEditSession
 */
export interface BeginEditSession {
  /**
   *
   * @type {number}
   * @memberof BeginEditSession
   */
  version: number
}
/**
 *
 * @export
 * @interface BeginUploadSession
 */
export interface BeginUploadSession {
  /**
   *
   * @type {Array<string>}
   * @memberof BeginUploadSession
   */
  groups: Array<string>
  /**
   *
   * @type {string}
   * @memberof BeginUploadSession
   */
  manga: string
}
/**
 *
 * @export
 * @interface CaptchaSolveBody
 */
export interface CaptchaSolveBody {
  /**
   *
   * @type {string}
   * @memberof CaptchaSolveBody
   */
  captchaChallenge: string
}
/**
 *
 * @export
 * @interface Chapter
 */
export interface Chapter {}
/**
 *
 * @export
 * @interface ChapterDraft
 */
export interface ChapterDraft {
  /**
   *
   * @type {string}
   * @memberof ChapterDraft
   */
  volume: string
  /**
   *
   * @type {string}
   * @memberof ChapterDraft
   */
  chapter: string
  /**
   *
   * @type {string}
   * @memberof ChapterDraft
   */
  title: string
  /**
   *
   * @type {string}
   * @memberof ChapterDraft
   */
  translatedLanguage: string
  /**
   *
   * @type {string}
   * @memberof ChapterDraft
   */
  externalUrl?: string
  /**
   *
   * @type {string}
   * @memberof ChapterDraft
   */
  publishAt?: string
}
/**
 *
 * @export
 * @interface ChapterEdit
 */
export interface ChapterEdit extends ChapterRequest {}
/**
 *
 * @export
 * @interface ChapterList
 */
export interface ChapterList {
  /**
   *
   * @type {string}
   * @memberof ChapterList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof ChapterList
   */
  response?: string
  /**
   *
   * @type {Array<Chapter>}
   * @memberof ChapterList
   */
  data?: Array<Chapter>
  /**
   *
   * @type {number}
   * @memberof ChapterList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof ChapterList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof ChapterList
   */
  total?: number
}
/**
 *
 * @export
 * @interface ChapterReadMarkerBatch
 */
export interface ChapterReadMarkerBatch {
  /**
   *
   * @type {Array<string>}
   * @memberof ChapterReadMarkerBatch
   */
  chapterIdsRead?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof ChapterReadMarkerBatch
   */
  chapterIdsUnread?: Array<string>
}
/**
 *
 * @export
 * @interface ChapterResponse
 */
export interface ChapterResponse {
  /**
   *
   * @type {string}
   * @memberof ChapterResponse
   */
  result?: ChapterResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof ChapterResponse
   */
  response?: string
  /**
   *
   * @type {Chapter}
   * @memberof ChapterResponse
   */
  data?: Chapter
}

/**
 * @export
 * @namespace ChapterResponse
 */
export namespace ChapterResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface CheckResponse
 */
export interface CheckResponse {
  /**
   *
   * @type {string}
   * @memberof CheckResponse
   */
  result?: string
  /**
   *
   * @type {boolean}
   * @memberof CheckResponse
   */
  isAuthenticated?: boolean
  /**
   *
   * @type {Array<string>}
   * @memberof CheckResponse
   */
  roles?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof CheckResponse
   */
  permissions?: Array<string>
}
/**
 *
 * @export
 * @interface CommitUploadSession
 */
export interface CommitUploadSession {
  /**
   *
   * @type {ChapterDraft}
   * @memberof CommitUploadSession
   */
  chapterDraft?: ChapterDraft
  /**
   * ordered list of Upload Session File ids
   * @type {Array<string>}
   * @memberof CommitUploadSession
   */
  pageOrder?: Array<string>
}
/**
 *
 * @export
 * @interface Cover
 */
export interface Cover {
  /**
   *
   * @type {string}
   * @memberof Cover
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Cover
   */
  type?: Cover.TypeEnum
  /**
   *
   * @type {CoverAttributes}
   * @memberof Cover
   */
  attributes?: CoverAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof Cover
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace Cover
 */
export namespace Cover {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    CoverArt = <any>'cover_art'
  }
}
/**
 *
 * @export
 * @interface CoverAttributes
 */
/**
 *
 * @export
 * @interface CoverEdit
 */
export interface CoverEdit {
  /**
   *
   * @type {string}
   * @memberof CoverEdit
   */
  volume: string
  /**
   *
   * @type {string}
   * @memberof CoverEdit
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CoverEdit
   */
  locale?: string
  /**
   *
   * @type {number}
   * @memberof CoverEdit
   */
  version: number
}
/**
 *
 * @export
 * @interface CoverList
 */
export interface CoverList {
  /**
   *
   * @type {string}
   * @memberof CoverList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof CoverList
   */
  response?: string
  /**
   *
   * @type {Array<Cover>}
   * @memberof CoverList
   */
  data?: Array<Cover>
  /**
   *
   * @type {number}
   * @memberof CoverList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof CoverList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof CoverList
   */
  total?: number
}
/**
 *
 * @export
 * @interface CoverMangaOrCoverIdBody
 */
export interface CoverMangaOrCoverIdBody {
  /**
   *
   * @type {Blob}
   * @memberof CoverMangaOrCoverIdBody
   */
  file?: Blob
  /**
   *
   * @type {string}
   * @memberof CoverMangaOrCoverIdBody
   */
  volume?: string
  /**
   *
   * @type {string}
   * @memberof CoverMangaOrCoverIdBody
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CoverMangaOrCoverIdBody
   */
  locale?: string
}
/**
 *
 * @export
 * @interface CoverResponse
 */
export interface CoverResponse {
  /**
   *
   * @type {string}
   * @memberof CoverResponse
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof CoverResponse
   */
  response?: string
  /**
   *
   * @type {Cover}
   * @memberof CoverResponse
   */
  data?: Cover
}
/**
 *
 * @export
 * @interface CreateAccount
 */
export interface CreateAccount {
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  password: string
  /**
   *
   * @type {string}
   * @memberof CreateAccount
   */
  email: string
}
/**
 *
 * @export
 * @interface CreateScanlationGroup
 */
export interface CreateScanlationGroup {
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  website?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  ircServer?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  ircChannel?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  discord?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  contactEmail?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  twitter?: string
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  mangaUpdates?: string
  /**
   *
   * @type {boolean}
   * @memberof CreateScanlationGroup
   */
  inactive?: boolean
  /**
   *
   * @type {string}
   * @memberof CreateScanlationGroup
   */
  publishDelay?: string
}
/**
 *
 * @export
 * @interface CustomList
 */
export interface CustomList {
  /**
   *
   * @type {string}
   * @memberof CustomList
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof CustomList
   */
  type?: CustomList.TypeEnum
  /**
   *
   * @type {CustomListAttributes}
   * @memberof CustomList
   */
  attributes?: CustomListAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof CustomList
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace CustomList
 */
export namespace CustomList {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    CustomList = <any>'custom_list'
  }
}
/**
 *
 * @export
 * @interface CustomListAttributes
 */
export interface CustomListAttributes {
  /**
   *
   * @type {string}
   * @memberof CustomListAttributes
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CustomListAttributes
   */
  visibility?: CustomListAttributes.VisibilityEnum
  /**
   *
   * @type {number}
   * @memberof CustomListAttributes
   */
  version?: number
}

/**
 * @export
 * @namespace CustomListAttributes
 */
export namespace CustomListAttributes {
  /**
   * @export
   * @enum {string}
   */
  export enum VisibilityEnum {
    Private = <any>'private',
    Public = <any>'public'
  }
}
/**
 *
 * @export
 * @interface CustomListCreate
 */
export interface CustomListCreate {
  /**
   *
   * @type {string}
   * @memberof CustomListCreate
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof CustomListCreate
   */
  visibility?: CustomListCreate.VisibilityEnum
  /**
   *
   * @type {Array<string>}
   * @memberof CustomListCreate
   */
  manga?: Array<string>
  /**
   *
   * @type {number}
   * @memberof CustomListCreate
   */
  version?: number
}

/**
 * @export
 * @namespace CustomListCreate
 */
export namespace CustomListCreate {
  /**
   * @export
   * @enum {string}
   */
  export enum VisibilityEnum {
    Public = <any>'public',
    Private = <any>'private'
  }
}
/**
 *
 * @export
 * @interface CustomListEdit
 */
export interface CustomListEdit {
  /**
   *
   * @type {string}
   * @memberof CustomListEdit
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof CustomListEdit
   */
  visibility?: CustomListEdit.VisibilityEnum
  /**
   *
   * @type {Array<string>}
   * @memberof CustomListEdit
   */
  manga?: Array<string>
  /**
   *
   * @type {number}
   * @memberof CustomListEdit
   */
  version: number
}

/**
 * @export
 * @namespace CustomListEdit
 */
export namespace CustomListEdit {
  /**
   * @export
   * @enum {string}
   */
  export enum VisibilityEnum {
    Public = <any>'public',
    Private = <any>'private'
  }
}
/**
 *
 * @export
 * @interface CustomListList
 */
export interface CustomListList {
  /**
   *
   * @type {string}
   * @memberof CustomListList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof CustomListList
   */
  response?: string
  /**
   *
   * @type {Array<CustomList>}
   * @memberof CustomListList
   */
  data?: Array<CustomList>
  /**
   *
   * @type {number}
   * @memberof CustomListList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof CustomListList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof CustomListList
   */
  total?: number
}
/**
 *
 * @export
 * @interface CustomListResponse
 */
export interface CustomListResponse {
  /**
   *
   * @type {string}
   * @memberof CustomListResponse
   */
  result?: CustomListResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof CustomListResponse
   */
  response?: string
  /**
   *
   * @type {CustomList}
   * @memberof CustomListResponse
   */
  data?: CustomList
}

/**
 * @export
 * @namespace CustomListResponse
 */
export namespace CustomListResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  result?: string
  /**
   *
   * @type {Array<Error>}
   * @memberof ErrorResponse
   */
  errors?: Array<Error>
}
/**
 *
 * @export
 * @interface ForumsThreadBody
 */
export interface ForumsThreadBody {
  /**
   * The type of the resource
   * @type {string}
   * @memberof ForumsThreadBody
   */
  type?: ForumsThreadBody.TypeEnum
  /**
   * The id of the resource
   * @type {string}
   * @memberof ForumsThreadBody
   */
  id?: string
}

/**
 * @export
 * @namespace ForumsThreadBody
 */
export namespace ForumsThreadBody {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Manga = <any>'manga',
    Group = <any>'group',
    Chapter = <any>'chapter'
  }
}
/**
 *
 * @export
 * @interface ForumsThreadResponse
 */
export interface ForumsThreadResponse {
  /**
   *
   * @type {string}
   * @memberof ForumsThreadResponse
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof ForumsThreadResponse
   */
  response?: string
  /**
   *
   * @type {ForumsThreadResponseData}
   * @memberof ForumsThreadResponse
   */
  data?: ForumsThreadResponseData
}
/**
 *
 * @export
 * @interface ForumsThreadResponseData
 */
export interface ForumsThreadResponseData {
  /**
   *
   * @type {string}
   * @memberof ForumsThreadResponseData
   */
  type?: string
  /**
   * The id for the thread on the forums, accessible at `https://forums.mangadex.org/threads/:id`
   * @type {number}
   * @memberof ForumsThreadResponseData
   */
  id?: number
  /**
   *
   * @type {ForumsThreadResponseDataAttributes}
   * @memberof ForumsThreadResponseData
   */
  attributes?: ForumsThreadResponseDataAttributes
}
/**
 *
 * @export
 * @interface ForumsThreadResponseDataAttributes
 */
export interface ForumsThreadResponseDataAttributes {
  /**
   * The number of replies so far in the forums thread returned
   * @type {number}
   * @memberof ForumsThreadResponseDataAttributes
   */
  repliesCount?: number
}
/**
 *
 * @export
 * @interface IdCommitBody
 */
export interface IdCommitBody {
  /**
   *
   * @type {number}
   * @memberof IdCommitBody
   */
  version?: number
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: InlineResponse200Volumes; }}
   * @memberof InlineResponse200
   */
  volumes?: { [key: string]: InlineResponse200Volumes }
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2001
   */
  available?: boolean
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010
   */
  result?: InlineResponse20010.ResultEnum
  /**
   *
   * @type {Array<Error>}
   * @memberof InlineResponse20010
   */
  errors?: Array<Error>
  /**
   *
   * @type {Array<UploadSessionFile>}
   * @memberof InlineResponse20010
   */
  data?: Array<UploadSessionFile>
}

/**
 * @export
 * @namespace InlineResponse20010
 */
export namespace InlineResponse20010 {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: InlineResponse20011Ratings; }}
   * @memberof InlineResponse20011
   */
  ratings?: { [key: string]: InlineResponse20011Ratings }
}
/**
 *
 * @export
 * @interface InlineResponse20011Ratings
 */
export interface InlineResponse20011Ratings {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20011Ratings
   */
  rating?: number
  /**
   *
   * @type {Date}
   * @memberof InlineResponse20011Ratings
   */
  createdAt?: Date
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20012
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: InlineResponse20012Statistics; }}
   * @memberof InlineResponse20012
   */
  statistics?: { [key: string]: InlineResponse20012Statistics }
}
/**
 *
 * @export
 * @interface InlineResponse20012Statistics
 */
export interface InlineResponse20012Statistics {
  /**
   *
   * @type {StatisticsDetailsComments}
   * @memberof InlineResponse20012Statistics
   */
  comments?: StatisticsDetailsComments
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: InlineResponse20013Statistics; }}
   * @memberof InlineResponse20013
   */
  statistics?: { [key: string]: InlineResponse20013Statistics }
}
/**
 *
 * @export
 * @interface InlineResponse20013Rating
 */
export interface InlineResponse20013Rating {
  /**
   * Will be nullable if no ratings has been given
   * @type {number}
   * @memberof InlineResponse20013Rating
   */
  average?: number
  /**
   * Average weighted on all the Manga population
   * @type {number}
   * @memberof InlineResponse20013Rating
   */
  bayesian?: number
  /**
   *
   * @type {InlineResponse20013RatingDistribution}
   * @memberof InlineResponse20013Rating
   */
  distribution?: InlineResponse20013RatingDistribution
}
/**
 *
 * @export
 * @interface InlineResponse20013RatingDistribution
 */
export interface InlineResponse20013RatingDistribution {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _1?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _2?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _3?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _4?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _5?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _6?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _7?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _8?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _9?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013RatingDistribution
   */
  _10?: number
}
/**
 *
 * @export
 * @interface InlineResponse20013Statistics
 */
export interface InlineResponse20013Statistics {
  /**
   *
   * @type {StatisticsDetailsComments}
   * @memberof InlineResponse20013Statistics
   */
  comments?: StatisticsDetailsComments
  /**
   *
   * @type {InlineResponse20013Rating}
   * @memberof InlineResponse20013Statistics
   */
  rating?: InlineResponse20013Rating
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013Statistics
   */
  follows?: number
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20014
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: InlineResponse20014Statistics; }}
   * @memberof InlineResponse20014
   */
  statistics?: { [key: string]: InlineResponse20014Statistics }
}
/**
 *
 * @export
 * @interface InlineResponse20014Rating
 */
export interface InlineResponse20014Rating {
  /**
   * Will be nullable if no ratings has been done
   * @type {number}
   * @memberof InlineResponse20014Rating
   */
  average?: number
  /**
   * Average weighted on all the Manga population
   * @type {number}
   * @memberof InlineResponse20014Rating
   */
  bayesian?: number
}
/**
 *
 * @export
 * @interface InlineResponse20014Statistics
 */
export interface InlineResponse20014Statistics {
  /**
   *
   * @type {StatisticsDetailsComments}
   * @memberof InlineResponse20014Statistics
   */
  comments?: StatisticsDetailsComments
  /**
   *
   * @type {InlineResponse20014Rating}
   * @memberof InlineResponse20014Statistics
   */
  rating?: InlineResponse20014Rating
  /**
   *
   * @type {number}
   * @memberof InlineResponse20014Statistics
   */
  follows?: number
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20015
   */
  result?: string
  /**
   *
   * @type {Date}
   * @memberof InlineResponse20015
   */
  updatedAt?: Date
  /**
   * Settings that were validated by linked template
   * @type {any}
   * @memberof InlineResponse20015
   */
  settings?: any
  /**
   * Settings template UUID
   * @type {string}
   * @memberof InlineResponse20015
   */
  template?: string
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20016
   */
  result?: string
  /**
   *
   * @type {Date}
   * @memberof InlineResponse20016
   */
  updatedAt?: Date
  /**
   * Settings that were validated against the linked template
   * @type {any}
   * @memberof InlineResponse20016
   */
  settings?: any
  /**
   * Settings template UUID
   * @type {string}
   * @memberof InlineResponse20016
   */
  template?: string
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20017
   */
  result?: string
  /**
   *
   * @type {Array<InlineResponse20017Ratings>}
   * @memberof InlineResponse20017
   */
  ratings?: Array<InlineResponse20017Ratings>
}
/**
 *
 * @export
 * @interface InlineResponse20017Ratings
 */
export interface InlineResponse20017Ratings {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20017Ratings
   */
  chapterId?: string
  /**
   *
   * @type {Date}
   * @memberof InlineResponse20017Ratings
   */
  readDate?: Date
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002
   */
  result?: InlineResponse2002.ResultEnum
}

/**
 * @export
 * @namespace InlineResponse2002
 */
export namespace InlineResponse2002 {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  result?: InlineResponse2003.ResultEnum
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2003
   */
  data?: Array<string>
}

/**
 * @export
 * @namespace InlineResponse2003
 */
export namespace InlineResponse2003 {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004
   */
  result?: InlineResponse2004.ResultEnum
  /**
   *
   * @type {Array<string> | Map}
   * @memberof InlineResponse2004
   */
  data?: Array<string> | Map
}

/**
 * @export
 * @namespace InlineResponse2004
 */
export namespace InlineResponse2004 {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  result?: string
  /**
   * The base URL to construct final image URLs from. The URL returned is valid for the requested chapter only, and for a duration of 15 minutes from the time of the response.
   * @type {string}
   * @memberof InlineResponse2005
   */
  baseUrl?: string
  /**
   *
   * @type {InlineResponse2005Chapter}
   * @memberof InlineResponse2005
   */
  chapter?: InlineResponse2005Chapter
}
/**
 *
 * @export
 * @interface InlineResponse2005Chapter
 */
export interface InlineResponse2005Chapter {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005Chapter
   */
  hash?: string
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2005Chapter
   */
  data?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2005Chapter
   */
  dataSaver?: Array<string>
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  result?: string
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof InlineResponse2006
   */
  statuses?: { [key: string]: string }
}

/**
 * @export
 * @namespace InlineResponse2006
 */
export namespace InlineResponse2006 {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusesEnum {
    Reading = <any>'reading',
    OnHold = <any>'on_hold',
    PlanToRead = <any>'plan_to_read',
    Dropped = <any>'dropped',
    ReReading = <any>'re_reading',
    Completed = <any>'completed'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof InlineResponse2007
   */
  status?: InlineResponse2007.StatusEnum
}

/**
 * @export
 * @namespace InlineResponse2007
 */
export namespace InlineResponse2007 {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Reading = <any>'reading',
    OnHold = <any>'on_hold',
    PlanToRead = <any>'plan_to_read',
    Dropped = <any>'dropped',
    ReReading = <any>'re_reading',
    Completed = <any>'completed'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008
   */
  result?: InlineResponse2008.ResultEnum
}

/**
 * @export
 * @namespace InlineResponse2008
 */
export namespace InlineResponse2008 {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009
   */
  response?: string
  /**
   *
   * @type {Array<InlineResponse2009Data>}
   * @memberof InlineResponse2009
   */
  data?: Array<InlineResponse2009Data>
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009
   */
  total?: number
}
/**
 *
 * @export
 * @interface InlineResponse2009Attributes
 */
export interface InlineResponse2009Attributes {
  /**
   *
   * @type {LocalizedString}
   * @memberof InlineResponse2009Attributes
   */
  reason?: LocalizedString
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2009Attributes
   */
  detailsRequired?: boolean
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Attributes
   */
  category?: InlineResponse2009Attributes.CategoryEnum
  /**
   *
   * @type {number}
   * @memberof InlineResponse2009Attributes
   */
  version?: number
}

/**
 * @export
 * @namespace InlineResponse2009Attributes
 */
export namespace InlineResponse2009Attributes {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Manga = <any>'manga',
    Chapter = <any>'chapter',
    ScanlationGroup = <any>'scanlation_group',
    User = <any>'user',
    Author = <any>'author'
  }
}
/**
 *
 * @export
 * @interface InlineResponse2009Data
 */
export interface InlineResponse2009Data {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Data
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof InlineResponse2009Data
   */
  type?: string
  /**
   *
   * @type {InlineResponse2009Attributes}
   * @memberof InlineResponse2009Data
   */
  attributes?: InlineResponse2009Attributes
}
/**
 *
 * @export
 * @interface InlineResponse200Chapters
 */
export interface InlineResponse200Chapters {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Chapters
   */
  chapter?: string
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Chapters
   */
  id?: string
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse200Chapters
   */
  others?: Array<string>
  /**
   *
   * @type {number}
   * @memberof InlineResponse200Chapters
   */
  count?: number
}
/**
 *
 * @export
 * @interface InlineResponse200Volumes
 */
export interface InlineResponse200Volumes {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Volumes
   */
  volume?: string
  /**
   *
   * @type {number}
   * @memberof InlineResponse200Volumes
   */
  count?: number
  /**
   *
   * @type {{ [key: string]: InlineResponse200Chapters; }}
   * @memberof InlineResponse200Volumes
   */
  chapters?: { [key: string]: InlineResponse200Chapters }
}
/**
 *
 * @export
 * @interface LocalizedString
 */
export interface LocalizedString extends null<String, string> {
  [key: string]: string
}
/**
 *
 * @export
 * @interface Login
 */
export interface Login {
  /**
   *
   * @type {string}
   * @memberof Login
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof Login
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof Login
   */
  password: string
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
  /**
   *
   * @type {string}
   * @memberof LoginResponse
   */
  result?: LoginResponse.ResultEnum
  /**
   *
   * @type {LoginResponseToken}
   * @memberof LoginResponse
   */
  token?: LoginResponseToken
}

/**
 * @export
 * @namespace LoginResponse
 */
export namespace LoginResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface LoginResponseToken
 */
export interface LoginResponseToken {
  /**
   *
   * @type {string}
   * @memberof LoginResponseToken
   */
  session?: string
  /**
   *
   * @type {string}
   * @memberof LoginResponseToken
   */
  refresh?: string
}
/**
 *
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
  /**
   *
   * @type {string}
   * @memberof LogoutResponse
   */
  result?: LogoutResponse.ResultEnum
}

/**
 * @export
 * @namespace LogoutResponse
 */
export namespace LogoutResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface Manga
 */
export interface Manga {
  /**
   *
   * @type {string}
   * @memberof Manga
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Manga
   */
  type?: Manga.TypeEnum
  /**
   *
   * @type {MangaAttributes}
   * @memberof Manga
   */
  attributes?: MangaAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof Manga
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace Manga
 */
export namespace Manga {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Manga = <any>'manga'
  }
}

export interface MangaIdBody extends MangaEdit {
  /**
   *
   * @type {Array<string>}
   * @memberof MangaIdBody
   */
  artists?: Array<string>
  /**
   *
   * @type {Array<string>}
   * @memberof MangaIdBody
   */
  authors?: Array<string>
}
/**
 *
 * @export
 * @interface MangaList
 */
export interface MangaList {
  /**
   *
   * @type {string}
   * @memberof MangaList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof MangaList
   */
  response?: string
  /**
   *
   * @type {Array<Manga>}
   * @memberof MangaList
   */
  data?: Array<Manga>
  /**
   *
   * @type {number}
   * @memberof MangaList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof MangaList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof MangaList
   */
  total?: number
}
/**
 *
 * @export
 * @interface MangaRelation
 */
export interface MangaRelation {
  /**
   *
   * @type {string}
   * @memberof MangaRelation
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof MangaRelation
   */
  type?: MangaRelation.TypeEnum
  /**
   *
   * @type {MangaRelationAttributes}
   * @memberof MangaRelation
   */
  attributes?: MangaRelationAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof MangaRelation
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace MangaRelation
 */
export namespace MangaRelation {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    MangaRelation = <any>'manga_relation'
  }
}
/**
 *
 * @export
 * @interface MangaRelationAttributes
 */
export interface MangaRelationAttributes {
  /**
   *
   * @type {string}
   * @memberof MangaRelationAttributes
   */
  relation?: MangaRelationAttributes.RelationEnum
  /**
   *
   * @type {number}
   * @memberof MangaRelationAttributes
   */
  version?: number
}

/**
 * @export
 * @namespace MangaRelationAttributes
 */
export namespace MangaRelationAttributes {
  /**
   * @export
   * @enum {string}
   */
  export enum RelationEnum {
    Monochrome = <any>'monochrome',
    MainStory = <any>'main_story',
    AdaptedFrom = <any>'adapted_from',
    BasedOn = <any>'based_on',
    Prequel = <any>'prequel',
    SideStory = <any>'side_story',
    Doujinshi = <any>'doujinshi',
    SameFranchise = <any>'same_franchise',
    SharedUniverse = <any>'shared_universe',
    Sequel = <any>'sequel',
    SpinOff = <any>'spin_off',
    AlternateStory = <any>'alternate_story',
    AlternateVersion = <any>'alternate_version',
    Preserialization = <any>'preserialization',
    Colored = <any>'colored',
    Serialization = <any>'serialization'
  }
}
/**
 *
 * @export
 * @interface MangaRelationCreate
 */
export interface MangaRelationCreate extends MangaRelationRequest {}

/**
 * @export
 * @namespace MangaRelationCreate
 */
export namespace MangaRelationCreate {}
/**
 *
 * @export
 * @interface MangaRelationList
 */
export interface MangaRelationList {
  /**
   *
   * @type {string}
   * @memberof MangaRelationList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof MangaRelationList
   */
  response?: string
  /**
   *
   * @type {Array<MangaRelation>}
   * @memberof MangaRelationList
   */
  data?: Array<MangaRelation>
  /**
   *
   * @type {number}
   * @memberof MangaRelationList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof MangaRelationList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof MangaRelationList
   */
  total?: number
}
/**
 *
 * @export
 * @interface MangaRelationRequest
 */
export interface MangaRelationRequest {
  /**
   *
   * @type {string}
   * @memberof MangaRelationRequest
   */
  targetManga?: string
  /**
   *
   * @type {string}
   * @memberof MangaRelationRequest
   */
  relation?: MangaRelationRequest.RelationEnum
}

/**
 * @export
 * @namespace MangaRelationRequest
 */
export namespace MangaRelationRequest {
  /**
   * @export
   * @enum {string}
   */
  export enum RelationEnum {
    Monochrome = <any>'monochrome',
    MainStory = <any>'main_story',
    AdaptedFrom = <any>'adapted_from',
    BasedOn = <any>'based_on',
    Prequel = <any>'prequel',
    SideStory = <any>'side_story',
    Doujinshi = <any>'doujinshi',
    SameFranchise = <any>'same_franchise',
    SharedUniverse = <any>'shared_universe',
    Sequel = <any>'sequel',
    SpinOff = <any>'spin_off',
    AlternateStory = <any>'alternate_story',
    AlternateVersion = <any>'alternate_version',
    Preserialization = <any>'preserialization',
    Colored = <any>'colored',
    Serialization = <any>'serialization'
  }
}
/**
 *
 * @export
 * @interface MangaRelationResponse
 */
export interface MangaRelationResponse {
  /**
   *
   * @type {string}
   * @memberof MangaRelationResponse
   */
  result?: MangaRelationResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof MangaRelationResponse
   */
  response?: string
  /**
   *
   * @type {MangaRelation}
   * @memberof MangaRelationResponse
   */
  data?: MangaRelation
}

/**
 * @export
 * @namespace MangaRelationResponse
 */
export namespace MangaRelationResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface MangaResponse
 */
export interface MangaResponse {
  /**
   *
   * @type {string}
   * @memberof MangaResponse
   */
  result?: MangaResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof MangaResponse
   */
  response?: string
  /**
   *
   * @type {Manga}
   * @memberof MangaResponse
   */
  data?: Manga
}

/**
 * @export
 * @namespace MangaResponse
 */
export namespace MangaResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface MappingId
 */
export interface MappingId {
  /**
   *
   * @type {string}
   * @memberof MappingId
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof MappingId
   */
  type?: MappingId.TypeEnum
  /**
   *
   * @type {MappingIdAttributes}
   * @memberof MappingId
   */
  attributes?: MappingIdAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof MappingId
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace MappingId
 */
export namespace MappingId {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    MappingId = <any>'mapping_id'
  }
}
/**
 *
 * @export
 * @interface MappingIdAttributes
 */
export interface MappingIdAttributes {
  /**
   *
   * @type {string}
   * @memberof MappingIdAttributes
   */
  type?: MappingIdAttributes.TypeEnum
  /**
   *
   * @type {number}
   * @memberof MappingIdAttributes
   */
  legacyId?: number
  /**
   *
   * @type {string}
   * @memberof MappingIdAttributes
   */
  newId?: string
}

/**
 * @export
 * @namespace MappingIdAttributes
 */
export namespace MappingIdAttributes {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Manga = <any>'manga',
    Chapter = <any>'chapter',
    Group = <any>'group',
    Tag = <any>'tag'
  }
}
/**
 *
 * @export
 * @interface MappingIdBody
 */
export interface MappingIdBody {
  /**
   *
   * @type {string}
   * @memberof MappingIdBody
   */
  type?: MappingIdBody.TypeEnum
  /**
   *
   * @type {Array<number>}
   * @memberof MappingIdBody
   */
  ids?: Array<number>
}

/**
 * @export
 * @namespace MappingIdBody
 */
export namespace MappingIdBody {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Group = <any>'group',
    Manga = <any>'manga',
    Chapter = <any>'chapter',
    Tag = <any>'tag'
  }
}
/**
 *
 * @export
 * @interface MappingIdResponse
 */
export interface MappingIdResponse {
  /**
   *
   * @type {string}
   * @memberof MappingIdResponse
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof MappingIdResponse
   */
  response?: string
  /**
   *
   * @type {Array<MappingId>}
   * @memberof MappingIdResponse
   */
  data?: Array<MappingId>
  /**
   *
   * @type {number}
   * @memberof MappingIdResponse
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof MappingIdResponse
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof MappingIdResponse
   */
  total?: number
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof ModelError
   */
  status?: number
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  title?: string
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  detail?: string
}
/**
 *
 * @export
 * @interface Order
 */
export interface Order {
  /**
   *
   * @type {string}
   * @memberof Order
   */
  title?: Order.TitleEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  year?: Order.YearEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  createdAt?: Order.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  updatedAt?: Order.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  latestUploadedChapter?: Order.LatestUploadedChapterEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  followedCount?: Order.FollowedCountEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  relevance?: Order.RelevanceEnum
  /**
   *
   * @type {string}
   * @memberof Order
   */
  rating?: Order.RatingEnum
}

/**
 * @export
 * @namespace Order
 */
export namespace Order {
  /**
   * @export
   * @enum {string}
   */
  export enum TitleEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum YearEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum LatestUploadedChapterEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum FollowedCountEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum RelevanceEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum RatingEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order1
 */
export interface Order1 {
  /**
   *
   * @type {string}
   * @memberof Order1
   */
  name?: Order1.NameEnum
  /**
   *
   * @type {string}
   * @memberof Order1
   */
  createdAt?: Order1.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order1
   */
  updatedAt?: Order1.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order1
   */
  followedCount?: Order1.FollowedCountEnum
  /**
   *
   * @type {string}
   * @memberof Order1
   */
  relevance?: Order1.RelevanceEnum
}

/**
 * @export
 * @namespace Order1
 */
export namespace Order1 {
  /**
   * @export
   * @enum {string}
   */
  export enum NameEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum FollowedCountEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum RelevanceEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order10
 */
export interface Order10 {
  /**
   *
   * @type {string}
   * @memberof Order10
   */
  createdAt?: Order10.CreatedAtEnum
}

/**
 * @export
 * @namespace Order10
 */
export namespace Order10 {
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order2
 */
export interface Order2 {
  /**
   *
   * @type {string}
   * @memberof Order2
   */
  username?: Order2.UsernameEnum
}

/**
 * @export
 * @namespace Order2
 */
export namespace Order2 {
  /**
   * @export
   * @enum {string}
   */
  export enum UsernameEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order3
 */
export interface Order3 {
  /**
   *
   * @type {string}
   * @memberof Order3
   */
  createdAt?: Order3.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order3
   */
  updatedAt?: Order3.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order3
   */
  publishAt?: Order3.PublishAtEnum
  /**
   *
   * @type {string}
   * @memberof Order3
   */
  readableAt?: Order3.ReadableAtEnum
  /**
   *
   * @type {string}
   * @memberof Order3
   */
  volume?: Order3.VolumeEnum
  /**
   *
   * @type {string}
   * @memberof Order3
   */
  chapter?: Order3.ChapterEnum
}

/**
 * @export
 * @namespace Order3
 */
export namespace Order3 {
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum PublishAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ReadableAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum VolumeEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ChapterEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order4
 */
export interface Order4 {
  /**
   *
   * @type {string}
   * @memberof Order4
   */
  createdAt?: Order4.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order4
   */
  updatedAt?: Order4.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order4
   */
  publishAt?: Order4.PublishAtEnum
  /**
   *
   * @type {string}
   * @memberof Order4
   */
  readableAt?: Order4.ReadableAtEnum
  /**
   *
   * @type {string}
   * @memberof Order4
   */
  volume?: Order4.VolumeEnum
  /**
   *
   * @type {string}
   * @memberof Order4
   */
  chapter?: Order4.ChapterEnum
}

/**
 * @export
 * @namespace Order4
 */
export namespace Order4 {
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum PublishAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ReadableAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum VolumeEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ChapterEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order5
 */
export interface Order5 {
  /**
   *
   * @type {string}
   * @memberof Order5
   */
  createdAt?: Order5.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order5
   */
  updatedAt?: Order5.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order5
   */
  publishAt?: Order5.PublishAtEnum
  /**
   *
   * @type {string}
   * @memberof Order5
   */
  readableAt?: Order5.ReadableAtEnum
  /**
   *
   * @type {string}
   * @memberof Order5
   */
  volume?: Order5.VolumeEnum
  /**
   *
   * @type {string}
   * @memberof Order5
   */
  chapter?: Order5.ChapterEnum
}

/**
 * @export
 * @namespace Order5
 */
export namespace Order5 {
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum PublishAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ReadableAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum VolumeEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ChapterEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order6
 */
export interface Order6 {
  /**
   *
   * @type {string}
   * @memberof Order6
   */
  createdAt?: Order6.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order6
   */
  updatedAt?: Order6.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order6
   */
  volume?: Order6.VolumeEnum
}

/**
 * @export
 * @namespace Order6
 */
export namespace Order6 {
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum VolumeEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order7
 */
export interface Order7 {
  /**
   *
   * @type {string}
   * @memberof Order7
   */
  name?: Order7.NameEnum
}

/**
 * @export
 * @namespace Order7
 */
export namespace Order7 {
  /**
   * @export
   * @enum {string}
   */
  export enum NameEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order8
 */
export interface Order8 {
  /**
   *
   * @type {string}
   * @memberof Order8
   */
  createdAt?: Order8.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order8
   */
  updatedAt?: Order8.UpdatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order8
   */
  publishAt?: Order8.PublishAtEnum
  /**
   *
   * @type {string}
   * @memberof Order8
   */
  readableAt?: Order8.ReadableAtEnum
  /**
   *
   * @type {string}
   * @memberof Order8
   */
  volume?: Order8.VolumeEnum
  /**
   *
   * @type {string}
   * @memberof Order8
   */
  chapter?: Order8.ChapterEnum
}

/**
 * @export
 * @namespace Order8
 */
export namespace Order8 {
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum PublishAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ReadableAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum VolumeEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ChapterEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface Order9
 */
export interface Order9 {
  /**
   *
   * @type {string}
   * @memberof Order9
   */
  title?: Order9.TitleEnum
  /**
   *
   * @type {string}
   * @memberof Order9
   */
  year?: Order9.YearEnum
  /**
   *
   * @type {string}
   * @memberof Order9
   */
  createdAt?: Order9.CreatedAtEnum
  /**
   *
   * @type {string}
   * @memberof Order9
   */
  updatedAt?: Order9.UpdatedAtEnum
}

/**
 * @export
 * @namespace Order9
 */
export namespace Order9 {
  /**
   * @export
   * @enum {string}
   */
  export enum TitleEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum YearEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum CreatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
  /**
   * @export
   * @enum {string}
   */
  export enum UpdatedAtEnum {
    Asc = <any>'asc',
    Desc = <any>'desc'
  }
}
/**
 *
 * @export
 * @interface RatingMangaIdBody
 */
export interface RatingMangaIdBody {
  /**
   *
   * @type {number}
   * @memberof RatingMangaIdBody
   */
  rating?: number
}
/**
 *
 * @export
 * @interface RecoverCompleteBody
 */
export interface RecoverCompleteBody {
  /**
   *
   * @type {string}
   * @memberof RecoverCompleteBody
   */
  newPassword: string
}
/**
 * Reference expansion options for author/artist entities or lists
 * @export
 */
export type ReferenceExpansionAuthor = Array<string>
/**
 * Reference expansion options for chapter entities or lists
 * @export
 */
export type ReferenceExpansionChapter = Array<string>
/**
 * Reference expansion options for cover art entities or lists
 * @export
 */
export type ReferenceExpansionCoverArt = Array<string>
/**
 * Reference expansion options for manga entities or lists
 * @export
 */
export type ReferenceExpansionManga = Array<string>
/**
 * Reference expansion options for manga relation entities or lists
 * @export
 */
export type ReferenceExpansionMangaRelation = Array<string>
/**
 * Reference expansion options for user report entities or lists
 * @export
 */
export type ReferenceExpansionReport = Array<string>
/**
 * Reference expansion options for scanlation group entities or lists
 * @export
 */
export type ReferenceExpansionScanlationGroup = Array<string>
/**
 *
 * @export
 * @interface RefreshResponse
 */
export interface RefreshResponse {
  /**
   *
   * @type {string}
   * @memberof RefreshResponse
   */
  result: RefreshResponse.ResultEnum
  /**
   *
   * @type {LoginResponseToken}
   * @memberof RefreshResponse
   */
  token?: LoginResponseToken
  /**
   *
   * @type {string}
   * @memberof RefreshResponse
   */
  message?: string
}

/**
 * @export
 * @namespace RefreshResponse
 */
export namespace RefreshResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
  /**
   *
   * @type {string}
   * @memberof RefreshToken
   */
  token: string
}
/**
 *
 * @export
 * @interface Relationship
 */
export interface Relationship {
  /**
   *
   * @type {string}
   * @memberof Relationship
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Relationship
   */
  type?: string
  /**
   * Related Manga type, only present if you are on a Manga entity and a Manga relationship
   * @type {string}
   * @memberof Relationship
   */
  related?: Relationship.RelatedEnum
  /**
   * If Reference Expansion is applied, contains objects attributes
   * @type {any}
   * @memberof Relationship
   */
  attributes?: any
}

/**
 *
 * @export
 * @interface Report
 */
export interface Report {
  /**
   *
   * @type {string}
   * @memberof Report
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Report
   */
  type?: Report.TypeEnum
  /**
   *
   * @type {ReportAttributes}
   * @memberof Report
   */
  attributes?: ReportAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof Report
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace Report
 */
export namespace Report {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Report = <any>'report'
  }
}
/**
 *
 * @export
 * @interface ReportAttributes
 */
export interface ReportAttributes {
  /**
   *
   * @type {string}
   * @memberof ReportAttributes
   */
  details?: string
  /**
   *
   * @type {string}
   * @memberof ReportAttributes
   */
  objectId?: string
  /**
   *
   * @type {string}
   * @memberof ReportAttributes
   */
  status?: ReportAttributes.StatusEnum
  /**
   *
   * @type {string}
   * @memberof ReportAttributes
   */
  createdAt?: string
}

/**
 * @export
 * @namespace ReportAttributes
 */
export namespace ReportAttributes {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Waiting = <any>'waiting',
    Accepted = <any>'accepted',
    Refused = <any>'refused',
    Autoresolved = <any>'autoresolved'
  }
}
/**
 *
 * @export
 * @interface ReportBody
 */
export interface ReportBody {
  /**
   *
   * @type {string}
   * @memberof ReportBody
   */
  category?: ReportBody.CategoryEnum
  /**
   *
   * @type {string}
   * @memberof ReportBody
   */
  reason?: string
  /**
   *
   * @type {string}
   * @memberof ReportBody
   */
  objectId?: string
  /**
   *
   * @type {string}
   * @memberof ReportBody
   */
  details?: string
}

/**
 * @export
 * @namespace ReportBody
 */
export namespace ReportBody {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Manga = <any>'manga',
    Chapter = <any>'chapter',
    User = <any>'user',
    ScanlationGroup = <any>'scanlation_group',
    Author = <any>'author'
  }
}
/**
 *
 * @export
 * @interface ReportListResponse
 */
export interface ReportListResponse {
  /**
   *
   * @type {string}
   * @memberof ReportListResponse
   */
  result?: ReportListResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof ReportListResponse
   */
  response?: string
  /**
   *
   * @type {Array<Report>}
   * @memberof ReportListResponse
   */
  data?: Array<Report>
  /**
   *
   * @type {number}
   * @memberof ReportListResponse
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof ReportListResponse
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof ReportListResponse
   */
  total?: number
}

/**
 * @export
 * @namespace ReportListResponse
 */
export namespace ReportListResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface Response
 */
export interface Response {
  /**
   *
   * @type {string}
   * @memberof Response
   */
  result?: Response.ResultEnum
}

/**
 * @export
 * @namespace Response
 */
export namespace Response {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok',
    Error = <any>'error'
  }
}
/**
 *
 * @export
 * @interface ScanlationGroup
 */
export interface ScanlationGroup {
  /**
   *
   * @type {string}
   * @memberof ScanlationGroup
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroup
   */
  type?: ScanlationGroup.TypeEnum
  /**
   *
   * @type {ScanlationGroupAttributes}
   * @memberof ScanlationGroup
   */
  attributes?: ScanlationGroupAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof ScanlationGroup
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace ScanlationGroup
 */
export namespace ScanlationGroup {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    ScanlationGroup = <any>'scanlation_group'
  }
}
/**
 *
 * @export
 * @interface ScanlationGroupAttributes
 */
export interface ScanlationGroupAttributes {
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  name?: string
  /**
   *
   * @type {Array<LocalizedString>}
   * @memberof ScanlationGroupAttributes
   */
  altNames?: Array<LocalizedString>
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  website?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  ircServer?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  ircChannel?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  discord?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  contactEmail?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  twitter?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  mangaUpdates?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ScanlationGroupAttributes
   */
  focusedLanguage?: Array<string>
  /**
   *
   * @type {boolean}
   * @memberof ScanlationGroupAttributes
   */
  locked?: boolean
  /**
   *
   * @type {boolean}
   * @memberof ScanlationGroupAttributes
   */
  official?: boolean
  /**
   *
   * @type {boolean}
   * @memberof ScanlationGroupAttributes
   */
  inactive?: boolean
  /**
   * Should respected ISO 8601 duration specification: https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  publishDelay?: string
  /**
   *
   * @type {number}
   * @memberof ScanlationGroupAttributes
   */
  version?: number
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupAttributes
   */
  updatedAt?: string
}
/**
 *
 * @export
 * @interface ScanlationGroupEdit
 */
export interface ScanlationGroupEdit {
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  leader?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ScanlationGroupEdit
   */
  members?: Array<string>
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  website?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  ircServer?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  ircChannel?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  discord?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  contactEmail?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  description?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  twitter?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  mangaUpdates?: string
  /**
   *
   * @type {Array<string>}
   * @memberof ScanlationGroupEdit
   */
  focusedLanguages?: Array<string>
  /**
   *
   * @type {boolean}
   * @memberof ScanlationGroupEdit
   */
  inactive?: boolean
  /**
   *
   * @type {boolean}
   * @memberof ScanlationGroupEdit
   */
  locked?: boolean
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupEdit
   */
  publishDelay?: string
  /**
   *
   * @type {number}
   * @memberof ScanlationGroupEdit
   */
  version: number
}
/**
 *
 * @export
 * @interface ScanlationGroupList
 */
export interface ScanlationGroupList {
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupList
   */
  response?: string
  /**
   *
   * @type {Array<ScanlationGroup>}
   * @memberof ScanlationGroupList
   */
  data?: Array<ScanlationGroup>
  /**
   *
   * @type {number}
   * @memberof ScanlationGroupList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof ScanlationGroupList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof ScanlationGroupList
   */
  total?: number
}
/**
 *
 * @export
 * @interface ScanlationGroupResponse
 */
export interface ScanlationGroupResponse {
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupResponse
   */
  result?: ScanlationGroupResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof ScanlationGroupResponse
   */
  response?: string
  /**
   *
   * @type {ScanlationGroup}
   * @memberof ScanlationGroupResponse
   */
  data?: ScanlationGroup
}

/**
 * @export
 * @namespace ScanlationGroupResponse
 */
export namespace ScanlationGroupResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok'
  }
}
/**
 *
 * @export
 * @interface SendAccountActivationCode
 */
export interface SendAccountActivationCode {
  /**
   *
   * @type {string}
   * @memberof SendAccountActivationCode
   */
  email: string
}
/**
 *
 * @export
 * @interface SettingsBody
 */
export interface SettingsBody {
  /**
   * A JSON object that can be validated against the lastest available template
   * @type {any}
   * @memberof SettingsBody
   */
  settings?: any
  /**
   * Format: 2022-03-14T13:19:37
   * @type {Date}
   * @memberof SettingsBody
   */
  updatedAt?: Date
}
/**
 * Comments-related statistics of an entity. If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
 * @export
 * @interface StatisticsDetailsComments
 */
export interface StatisticsDetailsComments {
  /**
   * The id of the thread backing the comments for that entity on the MangaDex Forums.
   * @type {number}
   * @memberof StatisticsDetailsComments
   */
  threadId?: number
  /**
   * The number of replies on the MangaDex Forums thread backing this entity's comments. This excludes the initial comment that opens the thread, which is created by our systems.
   * @type {number}
   * @memberof StatisticsDetailsComments
   */
  repliesCount?: number
}
/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof Tag
   */
  type?: Tag.TypeEnum
  /**
   *
   * @type {TagAttributes}
   * @memberof Tag
   */
  attributes?: TagAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof Tag
   */
  relationships?: Array<Relationship>
}

/**
 *
 * @export
 * @interface TagResponse
 */
export interface TagResponse {
  /**
   *
   * @type {string}
   * @memberof TagResponse
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof TagResponse
   */
  response?: string
  /**
   *
   * @type {Array<Tag>}
   * @memberof TagResponse
   */
  data?: Array<Tag>
  /**
   *
   * @type {number}
   * @memberof TagResponse
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof TagResponse
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof TagResponse
   */
  total?: number
}
/**
 *
 * @export
 * @interface UpdateMangaStatus
 */
export interface UpdateMangaStatus {
  /**
   *
   * @type {string}
   * @memberof UpdateMangaStatus
   */
  status: UpdateMangaStatus.StatusEnum
}

/**
 * @export
 * @namespace UpdateMangaStatus
 */
export namespace UpdateMangaStatus {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    Reading = <any>'reading',
    OnHold = <any>'on_hold',
    PlanToRead = <any>'plan_to_read',
    Dropped = <any>'dropped',
    ReReading = <any>'re_reading',
    Completed = <any>'completed'
  }
}
/**
 *
 * @export
 * @interface UploadSession
 */
export interface UploadSession {
  /**
   *
   * @type {string}
   * @memberof UploadSession
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof UploadSession
   */
  type?: UploadSession.TypeEnum
  /**
   *
   * @type {UploadSessionAttributes}
   * @memberof UploadSession
   */
  attributes?: UploadSessionAttributes
}

/**
 * @export
 * @namespace UploadSession
 */
export namespace UploadSession {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    UploadSession = <any>'upload_session'
  }
}
/**
 *
 * @export
 * @interface UploadSessionAttributes
 */
export interface UploadSessionAttributes {
  /**
   *
   * @type {boolean}
   * @memberof UploadSessionAttributes
   */
  isCommitted?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UploadSessionAttributes
   */
  isProcessed?: boolean
  /**
   *
   * @type {boolean}
   * @memberof UploadSessionAttributes
   */
  isDeleted?: boolean
  /**
   *
   * @type {number}
   * @memberof UploadSessionAttributes
   */
  version?: number
  /**
   *
   * @type {string}
   * @memberof UploadSessionAttributes
   */
  createdAt?: string
  /**
   *
   * @type {string}
   * @memberof UploadSessionAttributes
   */
  updatedAt?: string
}
/**
 *
 * @export
 * @interface UploadSessionFile
 */
export interface UploadSessionFile {
  /**
   *
   * @type {string}
   * @memberof UploadSessionFile
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof UploadSessionFile
   */
  type?: UploadSessionFile.TypeEnum
  /**
   *
   * @type {UploadSessionFileAttributes}
   * @memberof UploadSessionFile
   */
  attributes?: UploadSessionFileAttributes
}

/**
 * @export
 * @namespace UploadSessionFile
 */
export namespace UploadSessionFile {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    UploadSessionFile = <any>'upload_session_file'
  }
}
/**
 *
 * @export
 * @interface UploadSessionFileAttributes
 */
export interface UploadSessionFileAttributes {
  /**
   *
   * @type {string}
   * @memberof UploadSessionFileAttributes
   */
  originalFileName?: string
  /**
   *
   * @type {string}
   * @memberof UploadSessionFileAttributes
   */
  fileHash?: string
  /**
   *
   * @type {number}
   * @memberof UploadSessionFileAttributes
   */
  fileSize?: number
  /**
   *
   * @type {string}
   * @memberof UploadSessionFileAttributes
   */
  mimeType?: string
  /**
   *
   * @type {string}
   * @memberof UploadSessionFileAttributes
   */
  source?: UploadSessionFileAttributes.SourceEnum
  /**
   *
   * @type {number}
   * @memberof UploadSessionFileAttributes
   */
  version?: number
}

/**
 * @export
 * @namespace UploadSessionFileAttributes
 */
export namespace UploadSessionFileAttributes {
  /**
   * @export
   * @enum {string}
   */
  export enum SourceEnum {
    Local = <any>'local',
    Remote = <any>'remote'
  }
}
/**
 *
 * @export
 * @interface UploadUploadSessionIdBody
 */
export interface UploadUploadSessionIdBody {
  /**
   *
   * @type {Blob}
   * @memberof UploadUploadSessionIdBody
   */
  file?: Blob
}
/**
 *
 * @export
 * @interface Uploader
 */
export interface Uploader {}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  type?: User.TypeEnum
  /**
   *
   * @type {UserAttributes}
   * @memberof User
   */
  attributes?: UserAttributes
  /**
   *
   * @type {Array<Relationship>}
   * @memberof User
   */
  relationships?: Array<Relationship>
}

/**
 * @export
 * @namespace User
 */
export namespace User {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    User = <any>'user'
  }
}
/**
 *
 * @export
 * @interface UserAttributes
 */
export interface UserAttributes {
  /**
   *
   * @type {string}
   * @memberof UserAttributes
   */
  username?: string
  /**
   *
   * @type {Array<string>}
   * @memberof UserAttributes
   */
  roles?: Array<string>
  /**
   *
   * @type {number}
   * @memberof UserAttributes
   */
  version?: number
}
/**
 *
 * @export
 * @interface UserEmailBody
 */
export interface UserEmailBody {
  /**
   *
   * @type {string}
   * @memberof UserEmailBody
   */
  email: string
}
/**
 *
 * @export
 * @interface UserList
 */
export interface UserList {
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  result?: string
  /**
   *
   * @type {string}
   * @memberof UserList
   */
  response?: string
  /**
   *
   * @type {Array<User>}
   * @memberof UserList
   */
  data?: Array<User>
  /**
   *
   * @type {number}
   * @memberof UserList
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof UserList
   */
  offset?: number
  /**
   *
   * @type {number}
   * @memberof UserList
   */
  total?: number
}
/**
 *
 * @export
 * @interface UserPasswordBody
 */
export interface UserPasswordBody {
  /**
   *
   * @type {string}
   * @memberof UserPasswordBody
   */
  oldPassword: string
  /**
   *
   * @type {string}
   * @memberof UserPasswordBody
   */
  newPassword: string
}
/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  result?: UserResponse.ResultEnum
  /**
   *
   * @type {string}
   * @memberof UserResponse
   */
  response?: string
  /**
   *
   * @type {User}
   * @memberof UserResponse
   */
  data?: User
}

/**
 * @export
 * @namespace UserResponse
 */
export namespace UserResponse {
  /**
   * @export
   * @enum {string}
   */
  export enum ResultEnum {
    Ok = <any>'ok'
  }
}
/**
 *
 * @export
 * @interface Volume
 */
export interface Volume {}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Activate account
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountActivateCode(code: string, options: any = {}): FetchArgs {
      // verify required parameter 'code' is not null or undefined
      if (code === null || code === undefined) {
        throw new RequiredError(
          'code',
          'Required parameter code was null or undefined when calling getAccountActivateCode.'
        )
      }
      const localVarPath = `/account/activate/{code}`.replace(
        `{${'code'}}`,
        encodeURIComponent(String(code))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Account username available
     * @param {string} username Username to check for avaibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountAvailable(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          'username',
          'Required parameter username was null or undefined when calling getAccountAvailable.'
        )
      }
      const localVarPath = `/account/available`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Resend Activation code
     * @param {string} contentType
     * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountActivateResend(
      contentType: string,
      body?: SendAccountActivationCode,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAccountActivateResend.'
        )
      }
      const localVarPath = `/account/activate/resend`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'SendAccountActivationCode' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create Account
     * @param {string} contentType
     * @param {CreateAccount} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountCreate(
      contentType: string,
      body?: CreateAccount,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAccountCreate.'
        )
      }
      const localVarPath = `/account/create`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CreateAccount' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * You can only request Account Recovery once per Hour for the same Email Address
     * @summary Recover given Account
     * @param {string} contentType
     * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountRecover(
      contentType: string,
      body?: SendAccountActivationCode,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAccountRecover.'
        )
      }
      const localVarPath = `/account/recover`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'SendAccountActivationCode' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Complete Account recover
     * @param {string} code
     * @param {string} contentType
     * @param {RecoverCompleteBody} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountRecoverCode(
      code: string,
      contentType: string,
      body?: RecoverCompleteBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'code' is not null or undefined
      if (code === null || code === undefined) {
        throw new RequiredError(
          'code',
          'Required parameter code was null or undefined when calling postAccountRecoverCode.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAccountRecoverCode.'
        )
      }
      const localVarPath = `/account/recover/{code}`.replace(
        `{${'code'}}`,
        encodeURIComponent(String(code))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'RecoverCompleteBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Activate account
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountActivateCode(
      code: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AccountActivateResponse> {
      const localVarFetchArgs = AccountApiFetchParamCreator(
        configuration
      ).getAccountActivateCode(code, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Account username available
     * @param {string} username Username to check for avaibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountAvailable(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
      const localVarFetchArgs = AccountApiFetchParamCreator(
        configuration
      ).getAccountAvailable(username, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Resend Activation code
     * @param {string} contentType
     * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountActivateResend(
      contentType: string,
      body?: SendAccountActivationCode,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AccountActivateResponse> {
      const localVarFetchArgs = AccountApiFetchParamCreator(
        configuration
      ).postAccountActivateResend(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create Account
     * @param {string} contentType
     * @param {CreateAccount} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountCreate(
      contentType: string,
      body?: CreateAccount,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs = AccountApiFetchParamCreator(
        configuration
      ).postAccountCreate(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * You can only request Account Recovery once per Hour for the same Email Address
     * @summary Recover given Account
     * @param {string} contentType
     * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountRecover(
      contentType: string,
      body?: SendAccountActivationCode,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AccountActivateResponse> {
      const localVarFetchArgs = AccountApiFetchParamCreator(
        configuration
      ).postAccountRecover(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Complete Account recover
     * @param {string} code
     * @param {string} contentType
     * @param {RecoverCompleteBody} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountRecoverCode(
      code: string,
      contentType: string,
      body?: RecoverCompleteBody,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AccountActivateResponse> {
      const localVarFetchArgs = AccountApiFetchParamCreator(
        configuration
      ).postAccountRecoverCode(code, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Activate account
     * @param {string} code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountActivateCode(code: string, options?: any) {
      return AccountApiFp(configuration).getAccountActivateCode(code, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Account username available
     * @param {string} username Username to check for avaibility
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAccountAvailable(username: string, options?: any) {
      return AccountApiFp(configuration).getAccountAvailable(username, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Resend Activation code
     * @param {string} contentType
     * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountActivateResend(
      contentType: string,
      body?: SendAccountActivationCode,
      options?: any
    ) {
      return AccountApiFp(configuration).postAccountActivateResend(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Create Account
     * @param {string} contentType
     * @param {CreateAccount} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountCreate(
      contentType: string,
      body?: CreateAccount,
      options?: any
    ) {
      return AccountApiFp(configuration).postAccountCreate(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     * You can only request Account Recovery once per Hour for the same Email Address
     * @summary Recover given Account
     * @param {string} contentType
     * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountRecover(
      contentType: string,
      body?: SendAccountActivationCode,
      options?: any
    ) {
      return AccountApiFp(configuration).postAccountRecover(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Complete Account recover
     * @param {string} code
     * @param {string} contentType
     * @param {RecoverCompleteBody} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAccountRecoverCode(
      code: string,
      contentType: string,
      body?: RecoverCompleteBody,
      options?: any
    ) {
      return AccountApiFp(configuration).postAccountRecoverCode(
        code,
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
  /**
   *
   * @summary Activate account
   * @param {string} code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getAccountActivateCode(code: string, options?: any) {
    return AccountApiFp(this.configuration).getAccountActivateCode(
      code,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Account username available
   * @param {string} username Username to check for avaibility
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public getAccountAvailable(username: string, options?: any) {
    return AccountApiFp(this.configuration).getAccountAvailable(
      username,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Resend Activation code
   * @param {string} contentType
   * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public postAccountActivateResend(
    contentType: string,
    body?: SendAccountActivationCode,
    options?: any
  ) {
    return AccountApiFp(this.configuration).postAccountActivateResend(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Create Account
   * @param {string} contentType
   * @param {CreateAccount} [body] The size of the body is limited to 4KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public postAccountCreate(
    contentType: string,
    body?: CreateAccount,
    options?: any
  ) {
    return AccountApiFp(this.configuration).postAccountCreate(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * You can only request Account Recovery once per Hour for the same Email Address
   * @summary Recover given Account
   * @param {string} contentType
   * @param {SendAccountActivationCode} [body] The size of the body is limited to 1KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public postAccountRecover(
    contentType: string,
    body?: SendAccountActivationCode,
    options?: any
  ) {
    return AccountApiFp(this.configuration).postAccountRecover(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Complete Account recover
   * @param {string} code
   * @param {string} contentType
   * @param {RecoverCompleteBody} [body] The size of the body is limited to 2KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public postAccountRecoverCode(
    code: string,
    contentType: string,
    body?: RecoverCompleteBody,
    options?: any
  ) {
    return AccountApiFp(this.configuration).postAccountRecoverCode(
      code,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * AtHomeApi - fetch parameter creator
 * @export
 */
export const AtHomeApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get MangaDex@Home server URL
     * @param {string} chapterId Chapter ID
     * @param {boolean} [forcePort443] Force selecting from MangaDex@Home servers that use the standard HTTPS port 443.  While the conventional port for HTTPS traffic is 443 and servers are encouraged to use it, it is not a hard requirement as it technically isn&#x27;t anything special.  However, some misbehaving school/office network will at time block traffic to non-standard ports, and setting this flag to &#x60;true&#x60; will ensure selection of a server that uses these.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAtHomeServerChapterId(
      chapterId: string,
      forcePort443?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'chapterId' is not null or undefined
      if (chapterId === null || chapterId === undefined) {
        throw new RequiredError(
          'chapterId',
          'Required parameter chapterId was null or undefined when calling getAtHomeServerChapterId.'
        )
      }
      const localVarPath = `/at-home/server/{chapterId}`.replace(
        `{${'chapterId'}}`,
        encodeURIComponent(String(chapterId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (forcePort443 !== undefined) {
        localVarQueryParameter['forcePort443'] = forcePort443
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AtHomeApi - functional programming interface
 * @export
 */
export const AtHomeApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get MangaDex@Home server URL
     * @param {string} chapterId Chapter ID
     * @param {boolean} [forcePort443] Force selecting from MangaDex@Home servers that use the standard HTTPS port 443.  While the conventional port for HTTPS traffic is 443 and servers are encouraged to use it, it is not a hard requirement as it technically isn&#x27;t anything special.  However, some misbehaving school/office network will at time block traffic to non-standard ports, and setting this flag to &#x60;true&#x60; will ensure selection of a server that uses these.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAtHomeServerChapterId(
      chapterId: string,
      forcePort443?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2005> {
      const localVarFetchArgs = AtHomeApiFetchParamCreator(
        configuration
      ).getAtHomeServerChapterId(chapterId, forcePort443, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * AtHomeApi - factory interface
 * @export
 */
export const AtHomeApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get MangaDex@Home server URL
     * @param {string} chapterId Chapter ID
     * @param {boolean} [forcePort443] Force selecting from MangaDex@Home servers that use the standard HTTPS port 443.  While the conventional port for HTTPS traffic is 443 and servers are encouraged to use it, it is not a hard requirement as it technically isn&#x27;t anything special.  However, some misbehaving school/office network will at time block traffic to non-standard ports, and setting this flag to &#x60;true&#x60; will ensure selection of a server that uses these.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAtHomeServerChapterId(
      chapterId: string,
      forcePort443?: boolean,
      options?: any
    ) {
      return AtHomeApiFp(configuration).getAtHomeServerChapterId(
        chapterId,
        forcePort443,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * AtHomeApi - object-oriented interface
 * @export
 * @class AtHomeApi
 * @extends {BaseAPI}
 */
export class AtHomeApi extends BaseAPI {
  /**
   *
   * @summary Get MangaDex@Home server URL
   * @param {string} chapterId Chapter ID
   * @param {boolean} [forcePort443] Force selecting from MangaDex@Home servers that use the standard HTTPS port 443.  While the conventional port for HTTPS traffic is 443 and servers are encouraged to use it, it is not a hard requirement as it technically isn&#x27;t anything special.  However, some misbehaving school/office network will at time block traffic to non-standard ports, and setting this flag to &#x60;true&#x60; will ensure selection of a server that uses these.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AtHomeApi
   */
  public getAtHomeServerChapterId(
    chapterId: string,
    forcePort443?: boolean,
    options?: any
  ) {
    return AtHomeApiFp(this.configuration).getAtHomeServerChapterId(
      chapterId,
      forcePort443,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)
     * @summary Check the set of permissions associated with the current token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthCheck(options: any = {}): FetchArgs {
      const localVarPath = `/auth/check`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Login
     * @param {string} contentType
     * @param {Login} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogin(
      contentType: string,
      body?: Login,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAuthLogin.'
        )
      }
      const localVarPath = `/auth/login`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'Login' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogout(options: any = {}): FetchArgs {
      const localVarPath = `/auth/logout`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Refresh token
     * @param {string} contentType
     * @param {RefreshToken} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(
      contentType: string,
      body?: RefreshToken,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAuthRefresh.'
        )
      }
      const localVarPath = `/auth/refresh`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'RefreshToken' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
  return {
    /**
     * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)
     * @summary Check the set of permissions associated with the current token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthCheck(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CheckResponse> {
      const localVarFetchArgs =
        AuthenticationApiFetchParamCreator(configuration).getAuthCheck(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Login
     * @param {string} contentType
     * @param {Login} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogin(
      contentType: string,
      body?: Login,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LoginResponse> {
      const localVarFetchArgs = AuthenticationApiFetchParamCreator(
        configuration
      ).postAuthLogin(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogout(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<LogoutResponse> {
      const localVarFetchArgs =
        AuthenticationApiFetchParamCreator(configuration).postAuthLogout(
          options
        )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Refresh token
     * @param {string} contentType
     * @param {RefreshToken} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(
      contentType: string,
      body?: RefreshToken,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<RefreshResponse> {
      const localVarFetchArgs = AuthenticationApiFetchParamCreator(
        configuration
      ).postAuthRefresh(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)
     * @summary Check the set of permissions associated with the current token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthCheck(options?: any) {
      return AuthenticationApiFp(configuration).getAuthCheck(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Login
     * @param {string} contentType
     * @param {Login} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogin(contentType: string, body?: Login, options?: any) {
      return AuthenticationApiFp(configuration).postAuthLogin(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthLogout(options?: any) {
      return AuthenticationApiFp(configuration).postAuthLogout(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Refresh token
     * @param {string} contentType
     * @param {RefreshToken} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthRefresh(contentType: string, body?: RefreshToken, options?: any) {
      return AuthenticationApiFp(configuration).postAuthRefresh(
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
  /**
   * The returned list of permissions is computed depending on the generic role permissions that the token user has, their personal overrides, and the OpenID scopes of the token (we do not offer granular token permissions yet)
   * @summary Check the set of permissions associated with the current token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public getAuthCheck(options?: any) {
    return AuthenticationApiFp(this.configuration).getAuthCheck(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Login
   * @param {string} contentType
   * @param {Login} [body] The size of the body is limited to 2KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public postAuthLogin(contentType: string, body?: Login, options?: any) {
    return AuthenticationApiFp(this.configuration).postAuthLogin(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public postAuthLogout(options?: any) {
    return AuthenticationApiFp(this.configuration).postAuthLogout(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Refresh token
   * @param {string} contentType
   * @param {RefreshToken} [body] The size of the body is limited to 2KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthenticationApi
   */
  public postAuthRefresh(
    contentType: string,
    body?: RefreshToken,
    options?: any
  ) {
    return AuthenticationApiFp(this.configuration).postAuthRefresh(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * AuthorApi - fetch parameter creator
 * @export
 */
export const AuthorApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete Author
     * @param {string} id Author ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteAuthorId.'
        )
      }
      const localVarPath = `/author/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Author list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] Author ids (limited to 100 per request)
     * @param {string} [name]
     * @param {string} [orderName]
     * @param {ReferenceExpansionAuthor} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthor(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      name?: string,
      orderName?: string,
      includes?: ReferenceExpansionAuthor,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/author`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (orderName !== undefined) {
        localVarQueryParameter['order[name]'] = orderName
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get Author
     * @param {string} id Author ID
     * @param {ReferenceExpansionAuthor} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorId(
      id: string,
      includes?: ReferenceExpansionAuthor,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getAuthorId.'
        )
      }
      const localVarPath = `/author/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create Author
     * @param {string} contentType
     * @param {AuthorCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthor(
      contentType: string,
      body?: AuthorCreate,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postAuthor.'
        )
      }
      const localVarPath = `/author`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'AuthorCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update Author
     * @param {string} id Author ID
     * @param {string} contentType
     * @param {AuthorEdit} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAuthorId(
      id: string,
      contentType: string,
      body?: AuthorEdit,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling putAuthorId.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling putAuthorId.'
        )
      }
      const localVarPath = `/author/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'AuthorEdit' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * AuthorApi - functional programming interface
 * @export
 */
export const AuthorApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete Author
     * @param {string} id Author ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = AuthorApiFetchParamCreator(
        configuration
      ).deleteAuthorId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Author list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] Author ids (limited to 100 per request)
     * @param {string} [name]
     * @param {string} [orderName]
     * @param {ReferenceExpansionAuthor} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthor(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      name?: string,
      orderName?: string,
      includes?: ReferenceExpansionAuthor,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthorList> {
      const localVarFetchArgs = AuthorApiFetchParamCreator(
        configuration
      ).getAuthor(limit, offset, ids, name, orderName, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get Author
     * @param {string} id Author ID
     * @param {ReferenceExpansionAuthor} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorId(
      id: string,
      includes?: ReferenceExpansionAuthor,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthorResponse> {
      const localVarFetchArgs = AuthorApiFetchParamCreator(
        configuration
      ).getAuthorId(id, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create Author
     * @param {string} contentType
     * @param {AuthorCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthor(
      contentType: string,
      body?: AuthorCreate,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthorResponse> {
      const localVarFetchArgs = AuthorApiFetchParamCreator(
        configuration
      ).postAuthor(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update Author
     * @param {string} id Author ID
     * @param {string} contentType
     * @param {AuthorEdit} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAuthorId(
      id: string,
      contentType: string,
      body?: AuthorEdit,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AuthorResponse> {
      const localVarFetchArgs = AuthorApiFetchParamCreator(
        configuration
      ).putAuthorId(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * AuthorApi - factory interface
 * @export
 */
export const AuthorApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete Author
     * @param {string} id Author ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAuthorId(id: string, options?: any) {
      return AuthorApiFp(configuration).deleteAuthorId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Author list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] Author ids (limited to 100 per request)
     * @param {string} [name]
     * @param {string} [orderName]
     * @param {ReferenceExpansionAuthor} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthor(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      name?: string,
      orderName?: string,
      includes?: ReferenceExpansionAuthor,
      options?: any
    ) {
      return AuthorApiFp(configuration).getAuthor(
        limit,
        offset,
        ids,
        name,
        orderName,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get Author
     * @param {string} id Author ID
     * @param {ReferenceExpansionAuthor} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorId(
      id: string,
      includes?: ReferenceExpansionAuthor,
      options?: any
    ) {
      return AuthorApiFp(configuration).getAuthorId(
        id,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Create Author
     * @param {string} contentType
     * @param {AuthorCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postAuthor(contentType: string, body?: AuthorCreate, options?: any) {
      return AuthorApiFp(configuration).postAuthor(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Update Author
     * @param {string} id Author ID
     * @param {string} contentType
     * @param {AuthorEdit} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putAuthorId(
      id: string,
      contentType: string,
      body?: AuthorEdit,
      options?: any
    ) {
      return AuthorApiFp(configuration).putAuthorId(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * AuthorApi - object-oriented interface
 * @export
 * @class AuthorApi
 * @extends {BaseAPI}
 */
export class AuthorApi extends BaseAPI {
  /**
   *
   * @summary Delete Author
   * @param {string} id Author ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public deleteAuthorId(id: string, options?: any) {
    return AuthorApiFp(this.configuration).deleteAuthorId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Author list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [ids] Author ids (limited to 100 per request)
   * @param {string} [name]
   * @param {string} [orderName]
   * @param {ReferenceExpansionAuthor} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public getAuthor(
    limit?: number,
    offset?: number,
    ids?: Array<string>,
    name?: string,
    orderName?: string,
    includes?: ReferenceExpansionAuthor,
    options?: any
  ) {
    return AuthorApiFp(this.configuration).getAuthor(
      limit,
      offset,
      ids,
      name,
      orderName,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get Author
   * @param {string} id Author ID
   * @param {ReferenceExpansionAuthor} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public getAuthorId(
    id: string,
    includes?: ReferenceExpansionAuthor,
    options?: any
  ) {
    return AuthorApiFp(this.configuration).getAuthorId(
      id,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Create Author
   * @param {string} contentType
   * @param {AuthorCreate} [body] The size of the body is limited to 8KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public postAuthor(contentType: string, body?: AuthorCreate, options?: any) {
    return AuthorApiFp(this.configuration).postAuthor(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Update Author
   * @param {string} id Author ID
   * @param {string} contentType
   * @param {AuthorEdit} [body] The size of the body is limited to 8KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public putAuthorId(
    id: string,
    contentType: string,
    body?: AuthorEdit,
    options?: any
  ) {
    return AuthorApiFp(this.configuration).putAuthorId(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * CaptchaApi - fetch parameter creator
 * @export
 */
export const CaptchaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.  Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
     * @summary Solve Captcha
     * @param {string} contentType
     * @param {CaptchaSolveBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCaptchaSolve(
      contentType: string,
      body?: CaptchaSolveBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postCaptchaSolve.'
        )
      }
      const localVarPath = `/captcha/solve`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CaptchaSolveBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * CaptchaApi - functional programming interface
 * @export
 */
export const CaptchaApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.  Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
     * @summary Solve Captcha
     * @param {string} contentType
     * @param {CaptchaSolveBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCaptchaSolve(
      contentType: string,
      body?: CaptchaSolveBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2008> {
      const localVarFetchArgs = CaptchaApiFetchParamCreator(
        configuration
      ).postCaptchaSolve(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * CaptchaApi - factory interface
 * @export
 */
export const CaptchaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.  Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
     * @summary Solve Captcha
     * @param {string} contentType
     * @param {CaptchaSolveBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postCaptchaSolve(
      contentType: string,
      body?: CaptchaSolveBody,
      options?: any
    ) {
      return CaptchaApiFp(configuration).postCaptchaSolve(
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * CaptchaApi - object-oriented interface
 * @export
 * @class CaptchaApi
 * @extends {BaseAPI}
 */
export class CaptchaApi extends BaseAPI {
  /**
   * Captchas can be solved explicitly through this endpoint, another way is to add a `X-Captcha-Result` header to any request. The same logic will verify the captcha and is probably more convenient because it takes one less request.  Authentication is optional. Captchas are tracked for both the client ip and for the user id, if you are logged in you want to send your session token but that is not required.
   * @summary Solve Captcha
   * @param {string} contentType
   * @param {CaptchaSolveBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CaptchaApi
   */
  public postCaptchaSolve(
    contentType: string,
    body?: CaptchaSolveBody,
    options?: any
  ) {
    return CaptchaApiFp(this.configuration).postCaptchaSolve(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * ChapterApi - fetch parameter creator
 * @export
 */
export const ChapterApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete Chapter
     * @param {string} id Chapter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChapterId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteChapterId.'
        )
      }
      const localVarPath = `/chapter/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
     * @summary Chapter list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] Chapter ids (limited to 100 per request)
     * @param {string} [title]
     * @param {Array<string>} [groups]
     * @param {Uploader} [uploader]
     * @param {string} [manga]
     * @param {Volume} [volume]
     * @param {Chapter} [chapter]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {Array<string>} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChapter(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      title?: string,
      groups?: Array<string>,
      uploader?: Uploader,
      manga?: string,
      volume?: Volume,
      chapter?: Chapter,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: Array<string>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/chapter`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (groups) {
        localVarQueryParameter['groups[]'] = groups
      }

      if (uploader !== undefined) {
        localVarQueryParameter['uploader'] = uploader
      }

      if (manga !== undefined) {
        localVarQueryParameter['manga'] = manga
      }

      if (volume !== undefined) {
        localVarQueryParameter['volume[]'] = volume
      }

      if (chapter !== undefined) {
        localVarQueryParameter['chapter'] = chapter
      }

      if (translatedLanguage) {
        localVarQueryParameter['translatedLanguage[]'] = translatedLanguage
      }

      if (originalLanguage) {
        localVarQueryParameter['originalLanguage[]'] = originalLanguage
      }

      if (excludedOriginalLanguage) {
        localVarQueryParameter['excludedOriginalLanguage[]'] =
          excludedOriginalLanguage
      }

      if (contentRating) {
        localVarQueryParameter['contentRating[]'] = contentRating
      }

      if (excludedGroups) {
        localVarQueryParameter['excludedGroups[]'] = excludedGroups
      }

      if (excludedUploaders) {
        localVarQueryParameter['excludedUploaders[]'] = excludedUploaders
      }

      if (includeFutureUpdates !== undefined) {
        localVarQueryParameter['includeFutureUpdates'] = includeFutureUpdates
      }

      if (includeEmptyPages !== undefined) {
        localVarQueryParameter['includeEmptyPages'] = includeEmptyPages
      }

      if (includeFuturePublishAt !== undefined) {
        localVarQueryParameter['includeFuturePublishAt'] =
          includeFuturePublishAt
      }

      if (includeExternalUrl !== undefined) {
        localVarQueryParameter['includeExternalUrl'] = includeExternalUrl
      }

      if (createdAtSince !== undefined) {
        localVarQueryParameter['createdAtSince'] = createdAtSince
      }

      if (updatedAtSince !== undefined) {
        localVarQueryParameter['updatedAtSince'] = updatedAtSince
      }

      if (publishAtSince !== undefined) {
        localVarQueryParameter['publishAtSince'] = publishAtSince
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderPublishAt !== undefined) {
        localVarQueryParameter['order[publishAt]'] = orderPublishAt
      }

      if (orderReadableAt !== undefined) {
        localVarQueryParameter['order[readableAt]'] = orderReadableAt
      }

      if (orderVolume !== undefined) {
        localVarQueryParameter['order[volume]'] = orderVolume
      }

      if (orderChapter !== undefined) {
        localVarQueryParameter['order[chapter]'] = orderChapter
      }

      if (includes) {
        localVarQueryParameter['includes'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get Chapter
     * @param {string} id Chapter ID
     * @param {ReferenceExpansionChapter} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChapterId(
      id: string,
      includes?: ReferenceExpansionChapter,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getChapterId.'
        )
      }
      const localVarPath = `/chapter/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update Chapter
     * @param {string} id Chapter ID
     * @param {string} contentType
     * @param {ChapterEdit} [body] The size of the body is limited to 32KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChapterId(
      id: string,
      contentType: string,
      body?: ChapterEdit,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling putChapterId.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling putChapterId.'
        )
      }
      const localVarPath = `/chapter/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'ChapterEdit' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ChapterApi - functional programming interface
 * @export
 */
export const ChapterApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete Chapter
     * @param {string} id Chapter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChapterId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ChapterApiFetchParamCreator(
        configuration
      ).deleteChapterId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
     * @summary Chapter list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] Chapter ids (limited to 100 per request)
     * @param {string} [title]
     * @param {Array<string>} [groups]
     * @param {Uploader} [uploader]
     * @param {string} [manga]
     * @param {Volume} [volume]
     * @param {Chapter} [chapter]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {Array<string>} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChapter(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      title?: string,
      groups?: Array<string>,
      uploader?: Uploader,
      manga?: string,
      volume?: Volume,
      chapter?: Chapter,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: Array<string>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChapterList> {
      const localVarFetchArgs = ChapterApiFetchParamCreator(
        configuration
      ).getChapter(
        limit,
        offset,
        ids,
        title,
        groups,
        uploader,
        manga,
        volume,
        chapter,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get Chapter
     * @param {string} id Chapter ID
     * @param {ReferenceExpansionChapter} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChapterId(
      id: string,
      includes?: ReferenceExpansionChapter,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChapterResponse> {
      const localVarFetchArgs = ChapterApiFetchParamCreator(
        configuration
      ).getChapterId(id, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update Chapter
     * @param {string} id Chapter ID
     * @param {string} contentType
     * @param {ChapterEdit} [body] The size of the body is limited to 32KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChapterId(
      id: string,
      contentType: string,
      body?: ChapterEdit,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChapterResponse> {
      const localVarFetchArgs = ChapterApiFetchParamCreator(
        configuration
      ).putChapterId(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * ChapterApi - factory interface
 * @export
 */
export const ChapterApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete Chapter
     * @param {string} id Chapter ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChapterId(id: string, options?: any) {
      return ChapterApiFp(configuration).deleteChapterId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
     * @summary Chapter list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] Chapter ids (limited to 100 per request)
     * @param {string} [title]
     * @param {Array<string>} [groups]
     * @param {Uploader} [uploader]
     * @param {string} [manga]
     * @param {Volume} [volume]
     * @param {Chapter} [chapter]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {Array<string>} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChapter(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      title?: string,
      groups?: Array<string>,
      uploader?: Uploader,
      manga?: string,
      volume?: Volume,
      chapter?: Chapter,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: Array<string>,
      options?: any
    ) {
      return ChapterApiFp(configuration).getChapter(
        limit,
        offset,
        ids,
        title,
        groups,
        uploader,
        manga,
        volume,
        chapter,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get Chapter
     * @param {string} id Chapter ID
     * @param {ReferenceExpansionChapter} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChapterId(
      id: string,
      includes?: ReferenceExpansionChapter,
      options?: any
    ) {
      return ChapterApiFp(configuration).getChapterId(
        id,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Update Chapter
     * @param {string} id Chapter ID
     * @param {string} contentType
     * @param {ChapterEdit} [body] The size of the body is limited to 32KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putChapterId(
      id: string,
      contentType: string,
      body?: ChapterEdit,
      options?: any
    ) {
      return ChapterApiFp(configuration).putChapterId(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * ChapterApi - object-oriented interface
 * @export
 * @class ChapterApi
 * @extends {BaseAPI}
 */
export class ChapterApi extends BaseAPI {
  /**
   *
   * @summary Delete Chapter
   * @param {string} id Chapter ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChapterApi
   */
  public deleteChapterId(id: string, options?: any) {
    return ChapterApiFp(this.configuration).deleteChapterId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Chapter list. If you want the Chapters of a given Manga, please check the feed endpoints.
   * @summary Chapter list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [ids] Chapter ids (limited to 100 per request)
   * @param {string} [title]
   * @param {Array<string>} [groups]
   * @param {Uploader} [uploader]
   * @param {string} [manga]
   * @param {Volume} [volume]
   * @param {Chapter} [chapter]
   * @param {Array<string>} [translatedLanguage]
   * @param {Array<string>} [originalLanguage]
   * @param {Array<string>} [excludedOriginalLanguage]
   * @param {Array<string>} [contentRating]
   * @param {Array<string>} [excludedGroups]
   * @param {Array<string>} [excludedUploaders]
   * @param {string} [includeFutureUpdates]
   * @param {number} [includeEmptyPages]
   * @param {number} [includeFuturePublishAt]
   * @param {number} [includeExternalUrl]
   * @param {string} [createdAtSince]
   * @param {string} [updatedAtSince]
   * @param {string} [publishAtSince]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderPublishAt]
   * @param {string} [orderReadableAt]
   * @param {string} [orderVolume]
   * @param {string} [orderChapter]
   * @param {Array<string>} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChapterApi
   */
  public getChapter(
    limit?: number,
    offset?: number,
    ids?: Array<string>,
    title?: string,
    groups?: Array<string>,
    uploader?: Uploader,
    manga?: string,
    volume?: Volume,
    chapter?: Chapter,
    translatedLanguage?: Array<string>,
    originalLanguage?: Array<string>,
    excludedOriginalLanguage?: Array<string>,
    contentRating?: Array<string>,
    excludedGroups?: Array<string>,
    excludedUploaders?: Array<string>,
    includeFutureUpdates?: string,
    includeEmptyPages?: number,
    includeFuturePublishAt?: number,
    includeExternalUrl?: number,
    createdAtSince?: string,
    updatedAtSince?: string,
    publishAtSince?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderPublishAt?: string,
    orderReadableAt?: string,
    orderVolume?: string,
    orderChapter?: string,
    includes?: Array<string>,
    options?: any
  ) {
    return ChapterApiFp(this.configuration).getChapter(
      limit,
      offset,
      ids,
      title,
      groups,
      uploader,
      manga,
      volume,
      chapter,
      translatedLanguage,
      originalLanguage,
      excludedOriginalLanguage,
      contentRating,
      excludedGroups,
      excludedUploaders,
      includeFutureUpdates,
      includeEmptyPages,
      includeFuturePublishAt,
      includeExternalUrl,
      createdAtSince,
      updatedAtSince,
      publishAtSince,
      orderCreatedAt,
      orderUpdatedAt,
      orderPublishAt,
      orderReadableAt,
      orderVolume,
      orderChapter,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get Chapter
   * @param {string} id Chapter ID
   * @param {ReferenceExpansionChapter} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChapterApi
   */
  public getChapterId(
    id: string,
    includes?: ReferenceExpansionChapter,
    options?: any
  ) {
    return ChapterApiFp(this.configuration).getChapterId(
      id,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Update Chapter
   * @param {string} id Chapter ID
   * @param {string} contentType
   * @param {ChapterEdit} [body] The size of the body is limited to 32KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChapterApi
   */
  public putChapterId(
    id: string,
    contentType: string,
    body?: ChapterEdit,
    options?: any
  ) {
    return ChapterApiFp(this.configuration).putChapterId(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * CoverApi - fetch parameter creator
 * @export
 */
export const CoverApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCover(mangaOrCoverId: string, options: any = {}): FetchArgs {
      // verify required parameter 'mangaOrCoverId' is not null or undefined
      if (mangaOrCoverId === null || mangaOrCoverId === undefined) {
        throw new RequiredError(
          'mangaOrCoverId',
          'Required parameter mangaOrCoverId was null or undefined when calling deleteCover.'
        )
      }
      const localVarPath = `/cover/{mangaOrCoverId}`.replace(
        `{${'mangaOrCoverId'}}`,
        encodeURIComponent(String(mangaOrCoverId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Edit Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {string} contentType
     * @param {CoverEdit} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCover(
      mangaOrCoverId: string,
      contentType: string,
      body?: CoverEdit,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaOrCoverId' is not null or undefined
      if (mangaOrCoverId === null || mangaOrCoverId === undefined) {
        throw new RequiredError(
          'mangaOrCoverId',
          'Required parameter mangaOrCoverId was null or undefined when calling editCover.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling editCover.'
        )
      }
      const localVarPath = `/cover/{mangaOrCoverId}`.replace(
        `{${'mangaOrCoverId'}}`,
        encodeURIComponent(String(mangaOrCoverId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CoverEdit' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary CoverArt list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [manga] Manga ids (limited to 100 per request)
     * @param {Array<string>} [ids] Covers ids (limited to 100 per request)
     * @param {Array<string>} [uploaders] User ids (limited to 100 per request)
     * @param {Array<string>} [locales] Locales of cover art (limited to 100 per request)
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderVolume]
     * @param {ReferenceExpansionCoverArt} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCover(
      limit?: number,
      offset?: number,
      manga?: Array<string>,
      ids?: Array<string>,
      uploaders?: Array<string>,
      locales?: Array<string>,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderVolume?: string,
      includes?: ReferenceExpansionCoverArt,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/cover`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (manga) {
        localVarQueryParameter['manga[]'] = manga
      }

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (uploaders) {
        localVarQueryParameter['uploaders[]'] = uploaders
      }

      if (locales) {
        localVarQueryParameter['locales[]'] = locales
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderVolume !== undefined) {
        localVarQueryParameter['order[volume]'] = orderVolume
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {ReferenceExpansionCoverArt} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoverId(
      mangaOrCoverId: string,
      includes?: ReferenceExpansionCoverArt,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaOrCoverId' is not null or undefined
      if (mangaOrCoverId === null || mangaOrCoverId === undefined) {
        throw new RequiredError(
          'mangaOrCoverId',
          'Required parameter mangaOrCoverId was null or undefined when calling getCoverId.'
        )
      }
      const localVarPath = `/cover/{mangaOrCoverId}`.replace(
        `{${'mangaOrCoverId'}}`,
        encodeURIComponent(String(mangaOrCoverId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Upload Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {string} contentType
     * @param {Blob} [file]
     * @param {string} [volume]
     * @param {string} [description]
     * @param {string} [locale]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCover(
      mangaOrCoverId: string,
      contentType: string,
      file?: Blob,
      volume?: string,
      description?: string,
      locale?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaOrCoverId' is not null or undefined
      if (mangaOrCoverId === null || mangaOrCoverId === undefined) {
        throw new RequiredError(
          'mangaOrCoverId',
          'Required parameter mangaOrCoverId was null or undefined when calling uploadCover.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling uploadCover.'
        )
      }
      const localVarPath = `/cover/{mangaOrCoverId}`.replace(
        `{${'mangaOrCoverId'}}`,
        encodeURIComponent(String(mangaOrCoverId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      if (file !== undefined) {
        localVarFormParams.set('file', file as any)
      }

      if (volume !== undefined) {
        localVarFormParams.set('volume', volume as any)
      }

      if (description !== undefined) {
        localVarFormParams.set('description', description as any)
      }

      if (locale !== undefined) {
        localVarFormParams.set('locale', locale as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * CoverApi - functional programming interface
 * @export
 */
export const CoverApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCover(
      mangaOrCoverId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CoverApiFetchParamCreator(
        configuration
      ).deleteCover(mangaOrCoverId, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Edit Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {string} contentType
     * @param {CoverEdit} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCover(
      mangaOrCoverId: string,
      contentType: string,
      body?: CoverEdit,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoverResponse> {
      const localVarFetchArgs = CoverApiFetchParamCreator(
        configuration
      ).editCover(mangaOrCoverId, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary CoverArt list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [manga] Manga ids (limited to 100 per request)
     * @param {Array<string>} [ids] Covers ids (limited to 100 per request)
     * @param {Array<string>} [uploaders] User ids (limited to 100 per request)
     * @param {Array<string>} [locales] Locales of cover art (limited to 100 per request)
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderVolume]
     * @param {ReferenceExpansionCoverArt} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCover(
      limit?: number,
      offset?: number,
      manga?: Array<string>,
      ids?: Array<string>,
      uploaders?: Array<string>,
      locales?: Array<string>,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderVolume?: string,
      includes?: ReferenceExpansionCoverArt,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoverList> {
      const localVarFetchArgs = CoverApiFetchParamCreator(
        configuration
      ).getCover(
        limit,
        offset,
        manga,
        ids,
        uploaders,
        locales,
        orderCreatedAt,
        orderUpdatedAt,
        orderVolume,
        includes,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {ReferenceExpansionCoverArt} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoverId(
      mangaOrCoverId: string,
      includes?: ReferenceExpansionCoverArt,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoverResponse> {
      const localVarFetchArgs = CoverApiFetchParamCreator(
        configuration
      ).getCoverId(mangaOrCoverId, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Upload Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {string} contentType
     * @param {Blob} [file]
     * @param {string} [volume]
     * @param {string} [description]
     * @param {string} [locale]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCover(
      mangaOrCoverId: string,
      contentType: string,
      file?: Blob,
      volume?: string,
      description?: string,
      locale?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CoverResponse> {
      const localVarFetchArgs = CoverApiFetchParamCreator(
        configuration
      ).uploadCover(
        mangaOrCoverId,
        contentType,
        file,
        volume,
        description,
        locale,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * CoverApi - factory interface
 * @export
 */
export const CoverApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCover(mangaOrCoverId: string, options?: any) {
      return CoverApiFp(configuration).deleteCover(mangaOrCoverId, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Edit Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {string} contentType
     * @param {CoverEdit} [body] The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    editCover(
      mangaOrCoverId: string,
      contentType: string,
      body?: CoverEdit,
      options?: any
    ) {
      return CoverApiFp(configuration).editCover(
        mangaOrCoverId,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary CoverArt list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [manga] Manga ids (limited to 100 per request)
     * @param {Array<string>} [ids] Covers ids (limited to 100 per request)
     * @param {Array<string>} [uploaders] User ids (limited to 100 per request)
     * @param {Array<string>} [locales] Locales of cover art (limited to 100 per request)
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderVolume]
     * @param {ReferenceExpansionCoverArt} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCover(
      limit?: number,
      offset?: number,
      manga?: Array<string>,
      ids?: Array<string>,
      uploaders?: Array<string>,
      locales?: Array<string>,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderVolume?: string,
      includes?: ReferenceExpansionCoverArt,
      options?: any
    ) {
      return CoverApiFp(configuration).getCover(
        limit,
        offset,
        manga,
        ids,
        uploaders,
        locales,
        orderCreatedAt,
        orderUpdatedAt,
        orderVolume,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {ReferenceExpansionCoverArt} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCoverId(
      mangaOrCoverId: string,
      includes?: ReferenceExpansionCoverArt,
      options?: any
    ) {
      return CoverApiFp(configuration).getCoverId(
        mangaOrCoverId,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Upload Cover
     * @param {string} mangaOrCoverId Is Manga UUID on POST
     * @param {string} contentType
     * @param {Blob} [file]
     * @param {string} [volume]
     * @param {string} [description]
     * @param {string} [locale]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadCover(
      mangaOrCoverId: string,
      contentType: string,
      file?: Blob,
      volume?: string,
      description?: string,
      locale?: string,
      options?: any
    ) {
      return CoverApiFp(configuration).uploadCover(
        mangaOrCoverId,
        contentType,
        file,
        volume,
        description,
        locale,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * CoverApi - object-oriented interface
 * @export
 * @class CoverApi
 * @extends {BaseAPI}
 */
export class CoverApi extends BaseAPI {
  /**
   *
   * @summary Delete Cover
   * @param {string} mangaOrCoverId Is Manga UUID on POST
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoverApi
   */
  public deleteCover(mangaOrCoverId: string, options?: any) {
    return CoverApiFp(this.configuration).deleteCover(mangaOrCoverId, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Edit Cover
   * @param {string} mangaOrCoverId Is Manga UUID on POST
   * @param {string} contentType
   * @param {CoverEdit} [body] The size of the body is limited to 2KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoverApi
   */
  public editCover(
    mangaOrCoverId: string,
    contentType: string,
    body?: CoverEdit,
    options?: any
  ) {
    return CoverApiFp(this.configuration).editCover(
      mangaOrCoverId,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary CoverArt list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [manga] Manga ids (limited to 100 per request)
   * @param {Array<string>} [ids] Covers ids (limited to 100 per request)
   * @param {Array<string>} [uploaders] User ids (limited to 100 per request)
   * @param {Array<string>} [locales] Locales of cover art (limited to 100 per request)
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderVolume]
   * @param {ReferenceExpansionCoverArt} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoverApi
   */
  public getCover(
    limit?: number,
    offset?: number,
    manga?: Array<string>,
    ids?: Array<string>,
    uploaders?: Array<string>,
    locales?: Array<string>,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderVolume?: string,
    includes?: ReferenceExpansionCoverArt,
    options?: any
  ) {
    return CoverApiFp(this.configuration).getCover(
      limit,
      offset,
      manga,
      ids,
      uploaders,
      locales,
      orderCreatedAt,
      orderUpdatedAt,
      orderVolume,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get Cover
   * @param {string} mangaOrCoverId Is Manga UUID on POST
   * @param {ReferenceExpansionCoverArt} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoverApi
   */
  public getCoverId(
    mangaOrCoverId: string,
    includes?: ReferenceExpansionCoverArt,
    options?: any
  ) {
    return CoverApiFp(this.configuration).getCoverId(
      mangaOrCoverId,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Upload Cover
   * @param {string} mangaOrCoverId Is Manga UUID on POST
   * @param {string} contentType
   * @param {Blob} [file]
   * @param {string} [volume]
   * @param {string} [description]
   * @param {string} [locale]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CoverApi
   */
  public uploadCover(
    mangaOrCoverId: string,
    contentType: string,
    file?: Blob,
    volume?: string,
    description?: string,
    locale?: string,
    options?: any
  ) {
    return CoverApiFp(this.configuration).uploadCover(
      mangaOrCoverId,
      contentType,
      file,
      volume,
      description,
      locale,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * CustomListApi - fetch parameter creator
 * @export
 */
export const CustomListApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete CustomList
     * @param {string} id CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteListId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteListId.'
        )
      }
      const localVarPath = `/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Remove Manga in CustomList
     * @param {string} id Manga ID
     * @param {string} listId CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaIdListListId(
      id: string,
      listId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMangaIdListListId.'
        )
      }
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling deleteMangaIdListListId.'
        )
      }
      const localVarPath = `/manga/{id}/list/{listId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'listId'}}`, encodeURIComponent(String(listId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * The request body is empty
     * @summary Follow CustomList
     * @param {string} id CustomList ID
     * @param {string} contentType
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followListId(
      id: string,
      contentType: string,
      body?: any,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling followListId.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling followListId.'
        )
      }
      const localVarPath = `/list/{id}/follow`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'any' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get CustomList
     * @param {string} id CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getListId.'
        )
      }
      const localVarPath = `/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * This will list only public CustomList
     * @summary Get User's CustomList list
     * @param {string} id User ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdList(
      id: string,
      limit?: number,
      offset?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getUserIdList.'
        )
      }
      const localVarPath = `/user/{id}/list`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * This will list public and private CustomList
     * @summary Get logged User CustomList list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(limit?: number, offset?: number, options: any = {}): FetchArgs {
      const localVarPath = `/user/list`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create CustomList
     * @param {string} contentType
     * @param {CustomListCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postList(
      contentType: string,
      body?: CustomListCreate,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postList.'
        )
      }
      const localVarPath = `/list`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CustomListCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Add Manga in CustomList
     * @param {string} id Manga ID
     * @param {string} listId CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdListListId(
      id: string,
      listId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postMangaIdListListId.'
        )
      }
      // verify required parameter 'listId' is not null or undefined
      if (listId === null || listId === undefined) {
        throw new RequiredError(
          'listId',
          'Required parameter listId was null or undefined when calling postMangaIdListListId.'
        )
      }
      const localVarPath = `/manga/{id}/list/{listId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'listId'}}`, encodeURIComponent(String(listId)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * The size of the body is limited to 8KB.
     * @summary Update CustomList
     * @param {string} id CustomList ID
     * @param {string} contentType
     * @param {CustomListEdit} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putListId(
      id: string,
      contentType: string,
      body?: CustomListEdit,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling putListId.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling putListId.'
        )
      }
      const localVarPath = `/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CustomListEdit' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * The request body is empty
     * @summary Unfollow CustomList
     * @param {string} id CustomList ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowListId(id: string, body?: any, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling unfollowListId.'
        )
      }
      const localVarPath = `/list/{id}/follow`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'any' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * CustomListApi - functional programming interface
 * @export
 */
export const CustomListApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete CustomList
     * @param {string} id CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteListId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).deleteListId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Remove Manga in CustomList
     * @param {string} id Manga ID
     * @param {string} listId CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaIdListListId(
      id: string,
      listId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).deleteMangaIdListListId(id, listId, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * The request body is empty
     * @summary Follow CustomList
     * @param {string} id CustomList ID
     * @param {string} contentType
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followListId(
      id: string,
      contentType: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).followListId(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get CustomList
     * @param {string} id CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomListResponse> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).getListId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * This will list only public CustomList
     * @summary Get User's CustomList list
     * @param {string} id User ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdList(
      id: string,
      limit?: number,
      offset?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomListList> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).getUserIdList(id, limit, offset, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * This will list public and private CustomList
     * @summary Get logged User CustomList list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(
      limit?: number,
      offset?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomListList> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).getUserList(limit, offset, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create CustomList
     * @param {string} contentType
     * @param {CustomListCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postList(
      contentType: string,
      body?: CustomListCreate,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomListResponse> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).postList(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Add Manga in CustomList
     * @param {string} id Manga ID
     * @param {string} listId CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdListListId(
      id: string,
      listId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).postMangaIdListListId(id, listId, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * The size of the body is limited to 8KB.
     * @summary Update CustomList
     * @param {string} id CustomList ID
     * @param {string} contentType
     * @param {CustomListEdit} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putListId(
      id: string,
      contentType: string,
      body?: CustomListEdit,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomListResponse> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).putListId(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * The request body is empty
     * @summary Unfollow CustomList
     * @param {string} id CustomList ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowListId(
      id: string,
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
      const localVarFetchArgs = CustomListApiFetchParamCreator(
        configuration
      ).unfollowListId(id, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * CustomListApi - factory interface
 * @export
 */
export const CustomListApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete CustomList
     * @param {string} id CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteListId(id: string, options?: any) {
      return CustomListApiFp(configuration).deleteListId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Remove Manga in CustomList
     * @param {string} id Manga ID
     * @param {string} listId CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaIdListListId(id: string, listId: string, options?: any) {
      return CustomListApiFp(configuration).deleteMangaIdListListId(
        id,
        listId,
        options
      )(fetch, basePath)
    },
    /**
     * The request body is empty
     * @summary Follow CustomList
     * @param {string} id CustomList ID
     * @param {string} contentType
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followListId(id: string, contentType: string, body?: any, options?: any) {
      return CustomListApiFp(configuration).followListId(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get CustomList
     * @param {string} id CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListId(id: string, options?: any) {
      return CustomListApiFp(configuration).getListId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     * This will list only public CustomList
     * @summary Get User's CustomList list
     * @param {string} id User ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIdList(id: string, limit?: number, offset?: number, options?: any) {
      return CustomListApiFp(configuration).getUserIdList(
        id,
        limit,
        offset,
        options
      )(fetch, basePath)
    },
    /**
     * This will list public and private CustomList
     * @summary Get logged User CustomList list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserList(limit?: number, offset?: number, options?: any) {
      return CustomListApiFp(configuration).getUserList(
        limit,
        offset,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Create CustomList
     * @param {string} contentType
     * @param {CustomListCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postList(contentType: string, body?: CustomListCreate, options?: any) {
      return CustomListApiFp(configuration).postList(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Add Manga in CustomList
     * @param {string} id Manga ID
     * @param {string} listId CustomList ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdListListId(id: string, listId: string, options?: any) {
      return CustomListApiFp(configuration).postMangaIdListListId(
        id,
        listId,
        options
      )(fetch, basePath)
    },
    /**
     * The size of the body is limited to 8KB.
     * @summary Update CustomList
     * @param {string} id CustomList ID
     * @param {string} contentType
     * @param {CustomListEdit} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putListId(
      id: string,
      contentType: string,
      body?: CustomListEdit,
      options?: any
    ) {
      return CustomListApiFp(configuration).putListId(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     * The request body is empty
     * @summary Unfollow CustomList
     * @param {string} id CustomList ID
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowListId(id: string, body?: any, options?: any) {
      return CustomListApiFp(configuration).unfollowListId(
        id,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * CustomListApi - object-oriented interface
 * @export
 * @class CustomListApi
 * @extends {BaseAPI}
 */
export class CustomListApi extends BaseAPI {
  /**
   *
   * @summary Delete CustomList
   * @param {string} id CustomList ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public deleteListId(id: string, options?: any) {
    return CustomListApiFp(this.configuration).deleteListId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Remove Manga in CustomList
   * @param {string} id Manga ID
   * @param {string} listId CustomList ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public deleteMangaIdListListId(id: string, listId: string, options?: any) {
    return CustomListApiFp(this.configuration).deleteMangaIdListListId(
      id,
      listId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * The request body is empty
   * @summary Follow CustomList
   * @param {string} id CustomList ID
   * @param {string} contentType
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public followListId(
    id: string,
    contentType: string,
    body?: any,
    options?: any
  ) {
    return CustomListApiFp(this.configuration).followListId(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get CustomList
   * @param {string} id CustomList ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public getListId(id: string, options?: any) {
    return CustomListApiFp(this.configuration).getListId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * This will list only public CustomList
   * @summary Get User's CustomList list
   * @param {string} id User ID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public getUserIdList(
    id: string,
    limit?: number,
    offset?: number,
    options?: any
  ) {
    return CustomListApiFp(this.configuration).getUserIdList(
      id,
      limit,
      offset,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * This will list public and private CustomList
   * @summary Get logged User CustomList list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public getUserList(limit?: number, offset?: number, options?: any) {
    return CustomListApiFp(this.configuration).getUserList(
      limit,
      offset,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Create CustomList
   * @param {string} contentType
   * @param {CustomListCreate} [body] The size of the body is limited to 8KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public postList(contentType: string, body?: CustomListCreate, options?: any) {
    return CustomListApiFp(this.configuration).postList(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Add Manga in CustomList
   * @param {string} id Manga ID
   * @param {string} listId CustomList ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public postMangaIdListListId(id: string, listId: string, options?: any) {
    return CustomListApiFp(this.configuration).postMangaIdListListId(
      id,
      listId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * The size of the body is limited to 8KB.
   * @summary Update CustomList
   * @param {string} id CustomList ID
   * @param {string} contentType
   * @param {CustomListEdit} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public putListId(
    id: string,
    contentType: string,
    body?: CustomListEdit,
    options?: any
  ) {
    return CustomListApiFp(this.configuration).putListId(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * The request body is empty
   * @summary Unfollow CustomList
   * @param {string} id CustomList ID
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomListApi
   */
  public unfollowListId(id: string, body?: any, options?: any) {
    return CustomListApiFp(this.configuration).unfollowListId(
      id,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * FeedApi - fetch parameter creator
 * @export
 */
export const FeedApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary CustomList Manga feed
     * @param {string} id
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListIdFeed(
      id: string,
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getListIdFeed.'
        )
      }
      const localVarPath = `/list/{id}/feed`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (translatedLanguage) {
        localVarQueryParameter['translatedLanguage[]'] = translatedLanguage
      }

      if (originalLanguage) {
        localVarQueryParameter['originalLanguage[]'] = originalLanguage
      }

      if (excludedOriginalLanguage) {
        localVarQueryParameter['excludedOriginalLanguage[]'] =
          excludedOriginalLanguage
      }

      if (contentRating) {
        localVarQueryParameter['contentRating[]'] = contentRating
      }

      if (excludedGroups) {
        localVarQueryParameter['excludedGroups[]'] = excludedGroups
      }

      if (excludedUploaders) {
        localVarQueryParameter['excludedUploaders[]'] = excludedUploaders
      }

      if (includeFutureUpdates !== undefined) {
        localVarQueryParameter['includeFutureUpdates'] = includeFutureUpdates
      }

      if (createdAtSince !== undefined) {
        localVarQueryParameter['createdAtSince'] = createdAtSince
      }

      if (updatedAtSince !== undefined) {
        localVarQueryParameter['updatedAtSince'] = updatedAtSince
      }

      if (publishAtSince !== undefined) {
        localVarQueryParameter['publishAtSince'] = publishAtSince
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderPublishAt !== undefined) {
        localVarQueryParameter['order[publishAt]'] = orderPublishAt
      }

      if (orderReadableAt !== undefined) {
        localVarQueryParameter['order[readableAt]'] = orderReadableAt
      }

      if (orderVolume !== undefined) {
        localVarQueryParameter['order[volume]'] = orderVolume
      }

      if (orderChapter !== undefined) {
        localVarQueryParameter['order[chapter]'] = orderChapter
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      if (includeEmptyPages !== undefined) {
        localVarQueryParameter['includeEmptyPages'] = includeEmptyPages
      }

      if (includeFuturePublishAt !== undefined) {
        localVarQueryParameter['includeFuturePublishAt'] =
          includeFuturePublishAt
      }

      if (includeExternalUrl !== undefined) {
        localVarQueryParameter['includeExternalUrl'] = includeExternalUrl
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get logged User followed Manga feed (Chapter list)
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsMangaFeed(
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/user/follows/manga/feed`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (translatedLanguage) {
        localVarQueryParameter['translatedLanguage[]'] = translatedLanguage
      }

      if (originalLanguage) {
        localVarQueryParameter['originalLanguage[]'] = originalLanguage
      }

      if (excludedOriginalLanguage) {
        localVarQueryParameter['excludedOriginalLanguage[]'] =
          excludedOriginalLanguage
      }

      if (contentRating) {
        localVarQueryParameter['contentRating[]'] = contentRating
      }

      if (excludedGroups) {
        localVarQueryParameter['excludedGroups[]'] = excludedGroups
      }

      if (excludedUploaders) {
        localVarQueryParameter['excludedUploaders[]'] = excludedUploaders
      }

      if (includeFutureUpdates !== undefined) {
        localVarQueryParameter['includeFutureUpdates'] = includeFutureUpdates
      }

      if (createdAtSince !== undefined) {
        localVarQueryParameter['createdAtSince'] = createdAtSince
      }

      if (updatedAtSince !== undefined) {
        localVarQueryParameter['updatedAtSince'] = updatedAtSince
      }

      if (publishAtSince !== undefined) {
        localVarQueryParameter['publishAtSince'] = publishAtSince
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderPublishAt !== undefined) {
        localVarQueryParameter['order[publishAt]'] = orderPublishAt
      }

      if (orderReadableAt !== undefined) {
        localVarQueryParameter['order[readableAt]'] = orderReadableAt
      }

      if (orderVolume !== undefined) {
        localVarQueryParameter['order[volume]'] = orderVolume
      }

      if (orderChapter !== undefined) {
        localVarQueryParameter['order[chapter]'] = orderChapter
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      if (includeEmptyPages !== undefined) {
        localVarQueryParameter['includeEmptyPages'] = includeEmptyPages
      }

      if (includeFuturePublishAt !== undefined) {
        localVarQueryParameter['includeFuturePublishAt'] =
          includeFuturePublishAt
      }

      if (includeExternalUrl !== undefined) {
        localVarQueryParameter['includeExternalUrl'] = includeExternalUrl
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary CustomList Manga feed
     * @param {string} id
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListIdFeed(
      id: string,
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChapterList> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration
      ).getListIdFeed(
        id,
        limit,
        offset,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get logged User followed Manga feed (Chapter list)
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsMangaFeed(
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChapterList> {
      const localVarFetchArgs = FeedApiFetchParamCreator(
        configuration
      ).getUserFollowsMangaFeed(
        limit,
        offset,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary CustomList Manga feed
     * @param {string} id
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getListIdFeed(
      id: string,
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options?: any
    ) {
      return FeedApiFp(configuration).getListIdFeed(
        id,
        limit,
        offset,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get logged User followed Manga feed (Chapter list)
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsMangaFeed(
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options?: any
    ) {
      return FeedApiFp(configuration).getUserFollowsMangaFeed(
        limit,
        offset,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
  /**
   *
   * @summary CustomList Manga feed
   * @param {string} id
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [translatedLanguage]
   * @param {Array<string>} [originalLanguage]
   * @param {Array<string>} [excludedOriginalLanguage]
   * @param {Array<string>} [contentRating]
   * @param {Array<string>} [excludedGroups]
   * @param {Array<string>} [excludedUploaders]
   * @param {string} [includeFutureUpdates]
   * @param {string} [createdAtSince]
   * @param {string} [updatedAtSince]
   * @param {string} [publishAtSince]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderPublishAt]
   * @param {string} [orderReadableAt]
   * @param {string} [orderVolume]
   * @param {string} [orderChapter]
   * @param {ReferenceExpansionChapter} [includes]
   * @param {number} [includeEmptyPages]
   * @param {number} [includeFuturePublishAt]
   * @param {number} [includeExternalUrl]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public getListIdFeed(
    id: string,
    limit?: number,
    offset?: number,
    translatedLanguage?: Array<string>,
    originalLanguage?: Array<string>,
    excludedOriginalLanguage?: Array<string>,
    contentRating?: Array<string>,
    excludedGroups?: Array<string>,
    excludedUploaders?: Array<string>,
    includeFutureUpdates?: string,
    createdAtSince?: string,
    updatedAtSince?: string,
    publishAtSince?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderPublishAt?: string,
    orderReadableAt?: string,
    orderVolume?: string,
    orderChapter?: string,
    includes?: ReferenceExpansionChapter,
    includeEmptyPages?: number,
    includeFuturePublishAt?: number,
    includeExternalUrl?: number,
    options?: any
  ) {
    return FeedApiFp(this.configuration).getListIdFeed(
      id,
      limit,
      offset,
      translatedLanguage,
      originalLanguage,
      excludedOriginalLanguage,
      contentRating,
      excludedGroups,
      excludedUploaders,
      includeFutureUpdates,
      createdAtSince,
      updatedAtSince,
      publishAtSince,
      orderCreatedAt,
      orderUpdatedAt,
      orderPublishAt,
      orderReadableAt,
      orderVolume,
      orderChapter,
      includes,
      includeEmptyPages,
      includeFuturePublishAt,
      includeExternalUrl,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get logged User followed Manga feed (Chapter list)
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [translatedLanguage]
   * @param {Array<string>} [originalLanguage]
   * @param {Array<string>} [excludedOriginalLanguage]
   * @param {Array<string>} [contentRating]
   * @param {Array<string>} [excludedGroups]
   * @param {Array<string>} [excludedUploaders]
   * @param {string} [includeFutureUpdates]
   * @param {string} [createdAtSince]
   * @param {string} [updatedAtSince]
   * @param {string} [publishAtSince]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderPublishAt]
   * @param {string} [orderReadableAt]
   * @param {string} [orderVolume]
   * @param {string} [orderChapter]
   * @param {ReferenceExpansionChapter} [includes]
   * @param {number} [includeEmptyPages]
   * @param {number} [includeFuturePublishAt]
   * @param {number} [includeExternalUrl]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FeedApi
   */
  public getUserFollowsMangaFeed(
    limit?: number,
    offset?: number,
    translatedLanguage?: Array<string>,
    originalLanguage?: Array<string>,
    excludedOriginalLanguage?: Array<string>,
    contentRating?: Array<string>,
    excludedGroups?: Array<string>,
    excludedUploaders?: Array<string>,
    includeFutureUpdates?: string,
    createdAtSince?: string,
    updatedAtSince?: string,
    publishAtSince?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderPublishAt?: string,
    orderReadableAt?: string,
    orderVolume?: string,
    orderChapter?: string,
    includes?: ReferenceExpansionChapter,
    includeEmptyPages?: number,
    includeFuturePublishAt?: number,
    includeExternalUrl?: number,
    options?: any
  ) {
    return FeedApiFp(this.configuration).getUserFollowsMangaFeed(
      limit,
      offset,
      translatedLanguage,
      originalLanguage,
      excludedOriginalLanguage,
      contentRating,
      excludedGroups,
      excludedUploaders,
      includeFutureUpdates,
      createdAtSince,
      updatedAtSince,
      publishAtSince,
      orderCreatedAt,
      orderUpdatedAt,
      orderPublishAt,
      orderReadableAt,
      orderVolume,
      orderChapter,
      includes,
      includeEmptyPages,
      includeFuturePublishAt,
      includeExternalUrl,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * FollowsApi - fetch parameter creator
 * @export
 */
export const FollowsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get logged User followed Groups
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsGroup(
      limit?: number,
      offset?: number,
      includes?: ReferenceExpansionScanlationGroup,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/user/follows/group`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Check if logged User follows a Group
     * @param {string} id Scanlation Group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsGroupId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getUserFollowsGroupId.'
        )
      }
      const localVarPath = `/user/follows/group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get logged User followed CustomList list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsList(
      limit?: number,
      offset?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/user/follows/list`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Check if logged User follows a CustomList
     * @param {string} id CustomList id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsListId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getUserFollowsListId.'
        )
      }
      const localVarPath = `/user/follows/list/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get logged User followed Manga list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsManga(
      limit?: number,
      offset?: number,
      includes?: ReferenceExpansionManga,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/user/follows/manga`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Check if logged User follows a Manga
     * @param {string} id Manga id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsMangaId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getUserFollowsMangaId.'
        )
      }
      const localVarPath = `/user/follows/manga/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get logged User followed User list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsUser(
      limit?: number,
      offset?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/user/follows/user`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Check if logged User follows a User
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsUserId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getUserFollowsUserId.'
        )
      }
      const localVarPath = `/user/follows/user/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * FollowsApi - functional programming interface
 * @export
 */
export const FollowsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get logged User followed Groups
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsGroup(
      limit?: number,
      offset?: number,
      includes?: ReferenceExpansionScanlationGroup,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ScanlationGroupList> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsGroup(limit, offset, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Check if logged User follows a Group
     * @param {string} id Scanlation Group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsGroupId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsGroupId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get logged User followed CustomList list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsList(
      limit?: number,
      offset?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CustomListList> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsList(limit, offset, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Check if logged User follows a CustomList
     * @param {string} id CustomList id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsListId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsListId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get logged User followed Manga list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsManga(
      limit?: number,
      offset?: number,
      includes?: ReferenceExpansionManga,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaList> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsManga(limit, offset, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Check if logged User follows a Manga
     * @param {string} id Manga id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsMangaId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsMangaId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get logged User followed User list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsUser(
      limit?: number,
      offset?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserList> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsUser(limit, offset, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Check if logged User follows a User
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsUserId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = FollowsApiFetchParamCreator(
        configuration
      ).getUserFollowsUserId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * FollowsApi - factory interface
 * @export
 */
export const FollowsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get logged User followed Groups
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsGroup(
      limit?: number,
      offset?: number,
      includes?: ReferenceExpansionScanlationGroup,
      options?: any
    ) {
      return FollowsApiFp(configuration).getUserFollowsGroup(
        limit,
        offset,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Check if logged User follows a Group
     * @param {string} id Scanlation Group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsGroupId(id: string, options?: any) {
      return FollowsApiFp(configuration).getUserFollowsGroupId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get logged User followed CustomList list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsList(limit?: number, offset?: number, options?: any) {
      return FollowsApiFp(configuration).getUserFollowsList(
        limit,
        offset,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Check if logged User follows a CustomList
     * @param {string} id CustomList id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsListId(id: string, options?: any) {
      return FollowsApiFp(configuration).getUserFollowsListId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get logged User followed Manga list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsManga(
      limit?: number,
      offset?: number,
      includes?: ReferenceExpansionManga,
      options?: any
    ) {
      return FollowsApiFp(configuration).getUserFollowsManga(
        limit,
        offset,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Check if logged User follows a Manga
     * @param {string} id Manga id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsMangaId(id: string, options?: any) {
      return FollowsApiFp(configuration).getUserFollowsMangaId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get logged User followed User list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsUser(limit?: number, offset?: number, options?: any) {
      return FollowsApiFp(configuration).getUserFollowsUser(
        limit,
        offset,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Check if logged User follows a User
     * @param {string} id User id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserFollowsUserId(id: string, options?: any) {
      return FollowsApiFp(configuration).getUserFollowsUserId(id, options)(
        fetch,
        basePath
      )
    }
  }
}

/**
 * FollowsApi - object-oriented interface
 * @export
 * @class FollowsApi
 * @extends {BaseAPI}
 */
export class FollowsApi extends BaseAPI {
  /**
   *
   * @summary Get logged User followed Groups
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {ReferenceExpansionScanlationGroup} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsGroup(
    limit?: number,
    offset?: number,
    includes?: ReferenceExpansionScanlationGroup,
    options?: any
  ) {
    return FollowsApiFp(this.configuration).getUserFollowsGroup(
      limit,
      offset,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Check if logged User follows a Group
   * @param {string} id Scanlation Group id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsGroupId(id: string, options?: any) {
    return FollowsApiFp(this.configuration).getUserFollowsGroupId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get logged User followed CustomList list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsList(limit?: number, offset?: number, options?: any) {
    return FollowsApiFp(this.configuration).getUserFollowsList(
      limit,
      offset,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Check if logged User follows a CustomList
   * @param {string} id CustomList id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsListId(id: string, options?: any) {
    return FollowsApiFp(this.configuration).getUserFollowsListId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get logged User followed Manga list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {ReferenceExpansionManga} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsManga(
    limit?: number,
    offset?: number,
    includes?: ReferenceExpansionManga,
    options?: any
  ) {
    return FollowsApiFp(this.configuration).getUserFollowsManga(
      limit,
      offset,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Check if logged User follows a Manga
   * @param {string} id Manga id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsMangaId(id: string, options?: any) {
    return FollowsApiFp(this.configuration).getUserFollowsMangaId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get logged User followed User list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsUser(limit?: number, offset?: number, options?: any) {
    return FollowsApiFp(this.configuration).getUserFollowsUser(
      limit,
      offset,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Check if logged User follows a User
   * @param {string} id User id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FollowsApi
   */
  public getUserFollowsUserId(id: string, options?: any) {
    return FollowsApiFp(this.configuration).getUserFollowsUserId(id, options)(
      this.fetch,
      this.basePath
    )
  }
}
/**
 * ForumsApi - fetch parameter creator
 * @export
 */
export const ForumsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Creates a thread in the forums for the given resource, which backs the comments functionality. A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.
     * @summary Create forums thread
     * @param {ForumsThreadBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forumsThreadCreate(body?: ForumsThreadBody, options: any = {}): FetchArgs {
      const localVarPath = `/forums/thread`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'ForumsThreadBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ForumsApi - functional programming interface
 * @export
 */
export const ForumsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Creates a thread in the forums for the given resource, which backs the comments functionality. A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.
     * @summary Create forums thread
     * @param {ForumsThreadBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forumsThreadCreate(
      body?: ForumsThreadBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ForumsThreadResponse> {
      const localVarFetchArgs = ForumsApiFetchParamCreator(
        configuration
      ).forumsThreadCreate(body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * ForumsApi - factory interface
 * @export
 */
export const ForumsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Creates a thread in the forums for the given resource, which backs the comments functionality. A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.
     * @summary Create forums thread
     * @param {ForumsThreadBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forumsThreadCreate(body?: ForumsThreadBody, options?: any) {
      return ForumsApiFp(configuration).forumsThreadCreate(body, options)(
        fetch,
        basePath
      )
    }
  }
}

/**
 * ForumsApi - object-oriented interface
 * @export
 * @class ForumsApi
 * @extends {BaseAPI}
 */
export class ForumsApi extends BaseAPI {
  /**
   * Creates a thread in the forums for the given resource, which backs the comments functionality. A thread is only created if it doesn't exist yet; otherwise the preexisting thread is returned.
   * @summary Create forums thread
   * @param {ForumsThreadBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ForumsApi
   */
  public forumsThreadCreate(body?: ForumsThreadBody, options?: any) {
    return ForumsApiFp(this.configuration).forumsThreadCreate(body, options)(
      this.fetch,
      this.basePath
    )
  }
}
/**
 * InfrastructureApi - fetch parameter creator
 * @export
 */
export const InfrastructureApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a plaintext response containing only the word \"pong\" if the API is healthy
     * @summary Ping healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing(options: any = {}): FetchArgs {
      const localVarPath = `/ping`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * InfrastructureApi - functional programming interface
 * @export
 */
export const InfrastructureApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns a plaintext response containing only the word \"pong\" if the API is healthy
     * @summary Ping healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs =
        InfrastructureApiFetchParamCreator(configuration).getPing(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * InfrastructureApi - factory interface
 * @export
 */
export const InfrastructureApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns a plaintext response containing only the word \"pong\" if the API is healthy
     * @summary Ping healthcheck
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPing(options?: any) {
      return InfrastructureApiFp(configuration).getPing(options)(
        fetch,
        basePath
      )
    }
  }
}

/**
 * InfrastructureApi - object-oriented interface
 * @export
 * @class InfrastructureApi
 * @extends {BaseAPI}
 */
export class InfrastructureApi extends BaseAPI {
  /**
   * Returns a plaintext response containing only the word \"pong\" if the API is healthy
   * @summary Ping healthcheck
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InfrastructureApi
   */
  public getPing(options?: any) {
    return InfrastructureApiFp(this.configuration).getPing(options)(
      this.fetch,
      this.basePath
    )
  }
}
/**
 * LegacyApi - fetch parameter creator
 * @export
 */
export const LegacyApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Legacy ID mapping
     * @param {string} contentType
     * @param {MappingIdBody} [body] The size of the body is limited to 10KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLegacyMapping(
      contentType: string,
      body?: MappingIdBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postLegacyMapping.'
        )
      }
      const localVarPath = `/legacy/mapping`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'MappingIdBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * LegacyApi - functional programming interface
 * @export
 */
export const LegacyApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Legacy ID mapping
     * @param {string} contentType
     * @param {MappingIdBody} [body] The size of the body is limited to 10KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLegacyMapping(
      contentType: string,
      body?: MappingIdBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MappingIdResponse> {
      const localVarFetchArgs = LegacyApiFetchParamCreator(
        configuration
      ).postLegacyMapping(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * LegacyApi - factory interface
 * @export
 */
export const LegacyApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Legacy ID mapping
     * @param {string} contentType
     * @param {MappingIdBody} [body] The size of the body is limited to 10KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postLegacyMapping(
      contentType: string,
      body?: MappingIdBody,
      options?: any
    ) {
      return LegacyApiFp(configuration).postLegacyMapping(
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * LegacyApi - object-oriented interface
 * @export
 * @class LegacyApi
 * @extends {BaseAPI}
 */
export class LegacyApi extends BaseAPI {
  /**
   *
   * @summary Legacy ID mapping
   * @param {string} contentType
   * @param {MappingIdBody} [body] The size of the body is limited to 10KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LegacyApi
   */
  public postLegacyMapping(
    contentType: string,
    body?: MappingIdBody,
    options?: any
  ) {
    return LegacyApiFp(this.configuration).postLegacyMapping(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * MangaApi - fetch parameter creator
 * @export
 */
export const MangaApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Submit a Manga Draft
     * @param {string} id
     * @param {IdCommitBody} [body] A Manga Draft that is to be submitted must have at least one cover in the original language, must be in the &quot;draft&quot; state and must be passed the correct version in the request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitMangaDraft(
      id: string,
      body?: IdCommitBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling commitMangaDraft.'
        )
      }
      const localVarPath = `/manga/draft/{id}/commit`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'IdCommitBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Delete Manga
     * @param {string} id Manga ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMangaId.'
        )
      }
      const localVarPath = `/manga/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Unfollow Manga
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaIdFollow(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMangaIdFollow.'
        )
      }
      const localVarPath = `/manga/{id}/follow`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Delete Manga relation
     * @param {string} mangaId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaRelationId(
      mangaId: string,
      id: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaId' is not null or undefined
      if (mangaId === null || mangaId === undefined) {
        throw new RequiredError(
          'mangaId',
          'Required parameter mangaId was null or undefined when calling deleteMangaRelationId.'
        )
      }
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteMangaRelationId.'
        )
      }
      const localVarPath = `/manga/{mangaId}/relation/{id}`
        .replace(`{${'mangaId'}}`, encodeURIComponent(String(mangaId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get Manga volumes & chapters
     * @param {string} id Manga ID
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [groups]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaAggregate(
      id: string,
      translatedLanguage?: Array<string>,
      groups?: Array<string>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getMangaAggregate.'
        )
      }
      const localVarPath = `/manga/{id}/aggregate`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (translatedLanguage) {
        localVarQueryParameter['translatedLanguage[]'] = translatedLanguage
      }

      if (groups) {
        localVarQueryParameter['groups[]'] = groups
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a list of Manga Drafts
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [state]
     * @param {string} [orderTitle]
     * @param {string} [orderYear]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaDrafts(
      limit?: number,
      offset?: number,
      state?: string,
      orderTitle?: string,
      orderYear?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      includes?: ReferenceExpansionManga,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/manga/draft`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (state !== undefined) {
        localVarQueryParameter['state'] = state
      }

      if (orderTitle !== undefined) {
        localVarQueryParameter['order[title]'] = orderTitle
      }

      if (orderYear !== undefined) {
        localVarQueryParameter['order[year]'] = orderYear
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Get Manga.
     * @summary Get Manga
     * @param {string} id Manga ID
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaId(
      id: string,
      includes?: ReferenceExpansionManga,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getMangaId.'
        )
      }
      const localVarPath = `/manga/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a specific Manga Draft
     * @param {string} id
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdDraft(
      id: string,
      includes?: ReferenceExpansionManga,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getMangaIdDraft.'
        )
      }
      const localVarPath = `/manga/draft/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Manga feed
     * @param {string} id Manga ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdFeed(
      id: string,
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getMangaIdFeed.'
        )
      }
      const localVarPath = `/manga/{id}/feed`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (translatedLanguage) {
        localVarQueryParameter['translatedLanguage[]'] = translatedLanguage
      }

      if (originalLanguage) {
        localVarQueryParameter['originalLanguage[]'] = originalLanguage
      }

      if (excludedOriginalLanguage) {
        localVarQueryParameter['excludedOriginalLanguage[]'] =
          excludedOriginalLanguage
      }

      if (contentRating) {
        localVarQueryParameter['contentRating[]'] = contentRating
      }

      if (excludedGroups) {
        localVarQueryParameter['excludedGroups[]'] = excludedGroups
      }

      if (excludedUploaders) {
        localVarQueryParameter['excludedUploaders[]'] = excludedUploaders
      }

      if (includeFutureUpdates !== undefined) {
        localVarQueryParameter['includeFutureUpdates'] = includeFutureUpdates
      }

      if (createdAtSince !== undefined) {
        localVarQueryParameter['createdAtSince'] = createdAtSince
      }

      if (updatedAtSince !== undefined) {
        localVarQueryParameter['updatedAtSince'] = updatedAtSince
      }

      if (publishAtSince !== undefined) {
        localVarQueryParameter['publishAtSince'] = publishAtSince
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderPublishAt !== undefined) {
        localVarQueryParameter['order[publishAt]'] = orderPublishAt
      }

      if (orderReadableAt !== undefined) {
        localVarQueryParameter['order[readableAt]'] = orderReadableAt
      }

      if (orderVolume !== undefined) {
        localVarQueryParameter['order[volume]'] = orderVolume
      }

      if (orderChapter !== undefined) {
        localVarQueryParameter['order[chapter]'] = orderChapter
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      if (includeEmptyPages !== undefined) {
        localVarQueryParameter['includeEmptyPages'] = includeEmptyPages
      }

      if (includeFuturePublishAt !== undefined) {
        localVarQueryParameter['includeFuturePublishAt'] =
          includeFuturePublishAt
      }

      if (includeExternalUrl !== undefined) {
        localVarQueryParameter['includeExternalUrl'] = includeExternalUrl
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a Manga reading status
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdStatus(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getMangaIdStatus.'
        )
      }
      const localVarPath = `/manga/{id}/status`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a random Manga
     * @param {ReferenceExpansionManga} [includes]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [includedTags]
     * @param {string} [includedTagsMode]
     * @param {Array<string>} [excludedTags]
     * @param {string} [excludedTagsMode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaRandom(
      includes?: ReferenceExpansionManga,
      contentRating?: Array<string>,
      includedTags?: Array<string>,
      includedTagsMode?: string,
      excludedTags?: Array<string>,
      excludedTagsMode?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/manga/random`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      if (contentRating) {
        localVarQueryParameter['contentRating[]'] = contentRating
      }

      if (includedTags) {
        localVarQueryParameter['includedTags[]'] = includedTags
      }

      if (includedTagsMode !== undefined) {
        localVarQueryParameter['includedTagsMode'] = includedTagsMode
      }

      if (excludedTags) {
        localVarQueryParameter['excludedTags[]'] = excludedTags
      }

      if (excludedTagsMode !== undefined) {
        localVarQueryParameter['excludedTagsMode'] = excludedTagsMode
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Manga relation list
     * @param {string} mangaId
     * @param {ReferenceExpansionMangaRelation} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaRelation(
      mangaId: string,
      includes?: ReferenceExpansionMangaRelation,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaId' is not null or undefined
      if (mangaId === null || mangaId === undefined) {
        throw new RequiredError(
          'mangaId',
          'Required parameter mangaId was null or undefined when calling getMangaRelation.'
        )
      }
      const localVarPath = `/manga/{mangaId}/relation`.replace(
        `{${'mangaId'}}`,
        encodeURIComponent(String(mangaId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get all Manga reading status for logged User
     * @param {string} [status] Used to filter the list by given status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaStatus(status?: string, options: any = {}): FetchArgs {
      const localVarPath = `/manga/status`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Tag list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaTag(options: any = {}): FetchArgs {
      const localVarPath = `/manga/tag`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Search a list of Manga.
     * @summary Manga list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [title]
     * @param {string} [authorOrArtist]
     * @param {Array<string>} [authors]
     * @param {Array<string>} [artists]
     * @param {number} [year] Year of release
     * @param {Array<string>} [includedTags]
     * @param {string} [includedTagsMode]
     * @param {Array<string>} [excludedTags]
     * @param {string} [excludedTagsMode]
     * @param {Array<string>} [status]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [availableTranslatedLanguage]
     * @param {Array<string>} [publicationDemographic]
     * @param {Array<string>} [ids] Manga ids (limited to 100 per request)
     * @param {Array<string>} [contentRating]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [orderTitle]
     * @param {string} [orderYear]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderLatestUploadedChapter]
     * @param {string} [orderFollowedCount]
     * @param {string} [orderRelevance]
     * @param {string} [orderRating]
     * @param {ReferenceExpansionManga} [includes]
     * @param {string} [hasAvailableChapters]
     * @param {string} [group]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchManga(
      limit?: number,
      offset?: number,
      title?: string,
      authorOrArtist?: string,
      authors?: Array<string>,
      artists?: Array<string>,
      year?: number,
      includedTags?: Array<string>,
      includedTagsMode?: string,
      excludedTags?: Array<string>,
      excludedTagsMode?: string,
      status?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      availableTranslatedLanguage?: Array<string>,
      publicationDemographic?: Array<string>,
      ids?: Array<string>,
      contentRating?: Array<string>,
      createdAtSince?: string,
      updatedAtSince?: string,
      orderTitle?: string,
      orderYear?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderLatestUploadedChapter?: string,
      orderFollowedCount?: string,
      orderRelevance?: string,
      orderRating?: string,
      includes?: ReferenceExpansionManga,
      hasAvailableChapters?: string,
      group?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/manga`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      if (authorOrArtist !== undefined) {
        localVarQueryParameter['authorOrArtist'] = authorOrArtist
      }

      if (authors) {
        localVarQueryParameter['authors[]'] = authors
      }

      if (artists) {
        localVarQueryParameter['artists[]'] = artists
      }

      if (year !== undefined) {
        localVarQueryParameter['year'] = year
      }

      if (includedTags) {
        localVarQueryParameter['includedTags[]'] = includedTags
      }

      if (includedTagsMode !== undefined) {
        localVarQueryParameter['includedTagsMode'] = includedTagsMode
      }

      if (excludedTags) {
        localVarQueryParameter['excludedTags[]'] = excludedTags
      }

      if (excludedTagsMode !== undefined) {
        localVarQueryParameter['excludedTagsMode'] = excludedTagsMode
      }

      if (status) {
        localVarQueryParameter['status[]'] = status
      }

      if (originalLanguage) {
        localVarQueryParameter['originalLanguage[]'] = originalLanguage
      }

      if (excludedOriginalLanguage) {
        localVarQueryParameter['excludedOriginalLanguage[]'] =
          excludedOriginalLanguage
      }

      if (availableTranslatedLanguage) {
        localVarQueryParameter['availableTranslatedLanguage[]'] =
          availableTranslatedLanguage
      }

      if (publicationDemographic) {
        localVarQueryParameter['publicationDemographic[]'] =
          publicationDemographic
      }

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (contentRating) {
        localVarQueryParameter['contentRating[]'] = contentRating
      }

      if (createdAtSince !== undefined) {
        localVarQueryParameter['createdAtSince'] = createdAtSince
      }

      if (updatedAtSince !== undefined) {
        localVarQueryParameter['updatedAtSince'] = updatedAtSince
      }

      if (orderTitle !== undefined) {
        localVarQueryParameter['order[title]'] = orderTitle
      }

      if (orderYear !== undefined) {
        localVarQueryParameter['order[year]'] = orderYear
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderLatestUploadedChapter !== undefined) {
        localVarQueryParameter['order[latestUploadedChapter]'] =
          orderLatestUploadedChapter
      }

      if (orderFollowedCount !== undefined) {
        localVarQueryParameter['order[followedCount]'] = orderFollowedCount
      }

      if (orderRelevance !== undefined) {
        localVarQueryParameter['order[relevance]'] = orderRelevance
      }

      if (orderRating !== undefined) {
        localVarQueryParameter['order[rating]'] = orderRating
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      if (hasAvailableChapters !== undefined) {
        localVarQueryParameter['hasAvailableChapters'] = hasAvailableChapters
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Create a new Manga.
     * @summary Create Manga
     * @param {string} contentType
     * @param {MangaCreate} [body] The size of the body is limited to 64KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postManga(
      contentType: string,
      body?: MangaCreate,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postManga.'
        )
      }
      const localVarPath = `/manga`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'MangaCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Follow Manga
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdFollow(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postMangaIdFollow.'
        )
      }
      const localVarPath = `/manga/{id}/follow`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update Manga reading status
     * @param {string} id
     * @param {string} contentType
     * @param {UpdateMangaStatus} [body] Using a &#x60;null&#x60; value in &#x60;status&#x60; field will remove the Manga reading status. The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdStatus(
      id: string,
      contentType: string,
      body?: UpdateMangaStatus,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postMangaIdStatus.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postMangaIdStatus.'
        )
      }
      const localVarPath = `/manga/{id}/status`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'UpdateMangaStatus' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Create a new Manga relation.
     * @summary Create Manga relation
     * @param {string} mangaId
     * @param {string} contentType
     * @param {MangaRelationCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaRelation(
      mangaId: string,
      contentType: string,
      body?: MangaRelationCreate,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaId' is not null or undefined
      if (mangaId === null || mangaId === undefined) {
        throw new RequiredError(
          'mangaId',
          'Required parameter mangaId was null or undefined when calling postMangaRelation.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postMangaRelation.'
        )
      }
      const localVarPath = `/manga/{mangaId}/relation`.replace(
        `{${'mangaId'}}`,
        encodeURIComponent(String(mangaId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'MangaRelationCreate' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update Manga
     * @param {string} id Manga ID
     * @param {string} contentType
     * @param {MangaIdBody} [body] The size of the body is limited to 64KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMangaId(
      id: string,
      contentType: string,
      body?: MangaIdBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling putMangaId.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling putMangaId.'
        )
      }
      const localVarPath = `/manga/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'MangaIdBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * MangaApi - functional programming interface
 * @export
 */
export const MangaApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Submit a Manga Draft
     * @param {string} id
     * @param {IdCommitBody} [body] A Manga Draft that is to be submitted must have at least one cover in the original language, must be in the &quot;draft&quot; state and must be passed the correct version in the request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitMangaDraft(
      id: string,
      body?: IdCommitBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).commitMangaDraft(id, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Delete Manga
     * @param {string} id Manga ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).deleteMangaId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Unfollow Manga
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaIdFollow(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).deleteMangaIdFollow(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Delete Manga relation
     * @param {string} mangaId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaRelationId(
      mangaId: string,
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).deleteMangaRelationId(mangaId, id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get Manga volumes & chapters
     * @param {string} id Manga ID
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [groups]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaAggregate(
      id: string,
      translatedLanguage?: Array<string>,
      groups?: Array<string>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaAggregate(id, translatedLanguage, groups, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get a list of Manga Drafts
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [state]
     * @param {string} [orderTitle]
     * @param {string} [orderYear]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaDrafts(
      limit?: number,
      offset?: number,
      state?: string,
      orderTitle?: string,
      orderYear?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      includes?: ReferenceExpansionManga,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaDrafts(
        limit,
        offset,
        state,
        orderTitle,
        orderYear,
        orderCreatedAt,
        orderUpdatedAt,
        includes,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Get Manga.
     * @summary Get Manga
     * @param {string} id Manga ID
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaId(
      id: string,
      includes?: ReferenceExpansionManga,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaId(id, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get a specific Manga Draft
     * @param {string} id
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdDraft(
      id: string,
      includes?: ReferenceExpansionManga,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaIdDraft(id, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Manga feed
     * @param {string} id Manga ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdFeed(
      id: string,
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ChapterList> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaIdFeed(
        id,
        limit,
        offset,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get a Manga reading status
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdStatus(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2007> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaIdStatus(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get a random Manga
     * @param {ReferenceExpansionManga} [includes]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [includedTags]
     * @param {string} [includedTagsMode]
     * @param {Array<string>} [excludedTags]
     * @param {string} [excludedTagsMode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaRandom(
      includes?: ReferenceExpansionManga,
      contentRating?: Array<string>,
      includedTags?: Array<string>,
      includedTagsMode?: string,
      excludedTags?: Array<string>,
      excludedTagsMode?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaRandom(
        includes,
        contentRating,
        includedTags,
        includedTagsMode,
        excludedTags,
        excludedTagsMode,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Manga relation list
     * @param {string} mangaId
     * @param {ReferenceExpansionMangaRelation} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaRelation(
      mangaId: string,
      includes?: ReferenceExpansionMangaRelation,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaRelationList> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaRelation(mangaId, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get all Manga reading status for logged User
     * @param {string} [status] Used to filter the list by given status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaStatus(
      status?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2006> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getMangaStatus(status, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Tag list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaTag(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TagResponse> {
      const localVarFetchArgs =
        MangaApiFetchParamCreator(configuration).getMangaTag(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Search a list of Manga.
     * @summary Manga list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [title]
     * @param {string} [authorOrArtist]
     * @param {Array<string>} [authors]
     * @param {Array<string>} [artists]
     * @param {number} [year] Year of release
     * @param {Array<string>} [includedTags]
     * @param {string} [includedTagsMode]
     * @param {Array<string>} [excludedTags]
     * @param {string} [excludedTagsMode]
     * @param {Array<string>} [status]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [availableTranslatedLanguage]
     * @param {Array<string>} [publicationDemographic]
     * @param {Array<string>} [ids] Manga ids (limited to 100 per request)
     * @param {Array<string>} [contentRating]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [orderTitle]
     * @param {string} [orderYear]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderLatestUploadedChapter]
     * @param {string} [orderFollowedCount]
     * @param {string} [orderRelevance]
     * @param {string} [orderRating]
     * @param {ReferenceExpansionManga} [includes]
     * @param {string} [hasAvailableChapters]
     * @param {string} [group]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchManga(
      limit?: number,
      offset?: number,
      title?: string,
      authorOrArtist?: string,
      authors?: Array<string>,
      artists?: Array<string>,
      year?: number,
      includedTags?: Array<string>,
      includedTagsMode?: string,
      excludedTags?: Array<string>,
      excludedTagsMode?: string,
      status?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      availableTranslatedLanguage?: Array<string>,
      publicationDemographic?: Array<string>,
      ids?: Array<string>,
      contentRating?: Array<string>,
      createdAtSince?: string,
      updatedAtSince?: string,
      orderTitle?: string,
      orderYear?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderLatestUploadedChapter?: string,
      orderFollowedCount?: string,
      orderRelevance?: string,
      orderRating?: string,
      includes?: ReferenceExpansionManga,
      hasAvailableChapters?: string,
      group?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaList> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).getSearchManga(
        limit,
        offset,
        title,
        authorOrArtist,
        authors,
        artists,
        year,
        includedTags,
        includedTagsMode,
        excludedTags,
        excludedTagsMode,
        status,
        originalLanguage,
        excludedOriginalLanguage,
        availableTranslatedLanguage,
        publicationDemographic,
        ids,
        contentRating,
        createdAtSince,
        updatedAtSince,
        orderTitle,
        orderYear,
        orderCreatedAt,
        orderUpdatedAt,
        orderLatestUploadedChapter,
        orderFollowedCount,
        orderRelevance,
        orderRating,
        includes,
        hasAvailableChapters,
        group,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Create a new Manga.
     * @summary Create Manga
     * @param {string} contentType
     * @param {MangaCreate} [body] The size of the body is limited to 64KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postManga(
      contentType: string,
      body?: MangaCreate,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).postManga(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Follow Manga
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdFollow(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).postMangaIdFollow(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update Manga reading status
     * @param {string} id
     * @param {string} contentType
     * @param {UpdateMangaStatus} [body] Using a &#x60;null&#x60; value in &#x60;status&#x60; field will remove the Manga reading status. The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdStatus(
      id: string,
      contentType: string,
      body?: UpdateMangaStatus,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).postMangaIdStatus(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Create a new Manga relation.
     * @summary Create Manga relation
     * @param {string} mangaId
     * @param {string} contentType
     * @param {MangaRelationCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaRelation(
      mangaId: string,
      contentType: string,
      body?: MangaRelationCreate,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaRelationResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).postMangaRelation(mangaId, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update Manga
     * @param {string} id Manga ID
     * @param {string} contentType
     * @param {MangaIdBody} [body] The size of the body is limited to 64KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMangaId(
      id: string,
      contentType: string,
      body?: MangaIdBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<MangaResponse> {
      const localVarFetchArgs = MangaApiFetchParamCreator(
        configuration
      ).putMangaId(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * MangaApi - factory interface
 * @export
 */
export const MangaApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Submit a Manga Draft
     * @param {string} id
     * @param {IdCommitBody} [body] A Manga Draft that is to be submitted must have at least one cover in the original language, must be in the &quot;draft&quot; state and must be passed the correct version in the request body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitMangaDraft(id: string, body?: IdCommitBody, options?: any) {
      return MangaApiFp(configuration).commitMangaDraft(
        id,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Delete Manga
     * @param {string} id Manga ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaId(id: string, options?: any) {
      return MangaApiFp(configuration).deleteMangaId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Unfollow Manga
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaIdFollow(id: string, options?: any) {
      return MangaApiFp(configuration).deleteMangaIdFollow(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Delete Manga relation
     * @param {string} mangaId
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMangaRelationId(mangaId: string, id: string, options?: any) {
      return MangaApiFp(configuration).deleteMangaRelationId(
        mangaId,
        id,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get Manga volumes & chapters
     * @param {string} id Manga ID
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [groups]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaAggregate(
      id: string,
      translatedLanguage?: Array<string>,
      groups?: Array<string>,
      options?: any
    ) {
      return MangaApiFp(configuration).getMangaAggregate(
        id,
        translatedLanguage,
        groups,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get a list of Manga Drafts
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [state]
     * @param {string} [orderTitle]
     * @param {string} [orderYear]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaDrafts(
      limit?: number,
      offset?: number,
      state?: string,
      orderTitle?: string,
      orderYear?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      includes?: ReferenceExpansionManga,
      options?: any
    ) {
      return MangaApiFp(configuration).getMangaDrafts(
        limit,
        offset,
        state,
        orderTitle,
        orderYear,
        orderCreatedAt,
        orderUpdatedAt,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     * Get Manga.
     * @summary Get Manga
     * @param {string} id Manga ID
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaId(id: string, includes?: ReferenceExpansionManga, options?: any) {
      return MangaApiFp(configuration).getMangaId(
        id,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get a specific Manga Draft
     * @param {string} id
     * @param {ReferenceExpansionManga} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdDraft(
      id: string,
      includes?: ReferenceExpansionManga,
      options?: any
    ) {
      return MangaApiFp(configuration).getMangaIdDraft(
        id,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Manga feed
     * @param {string} id Manga ID
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [translatedLanguage]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [excludedGroups]
     * @param {Array<string>} [excludedUploaders]
     * @param {string} [includeFutureUpdates]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [publishAtSince]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderPublishAt]
     * @param {string} [orderReadableAt]
     * @param {string} [orderVolume]
     * @param {string} [orderChapter]
     * @param {ReferenceExpansionChapter} [includes]
     * @param {number} [includeEmptyPages]
     * @param {number} [includeFuturePublishAt]
     * @param {number} [includeExternalUrl]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdFeed(
      id: string,
      limit?: number,
      offset?: number,
      translatedLanguage?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      contentRating?: Array<string>,
      excludedGroups?: Array<string>,
      excludedUploaders?: Array<string>,
      includeFutureUpdates?: string,
      createdAtSince?: string,
      updatedAtSince?: string,
      publishAtSince?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderPublishAt?: string,
      orderReadableAt?: string,
      orderVolume?: string,
      orderChapter?: string,
      includes?: ReferenceExpansionChapter,
      includeEmptyPages?: number,
      includeFuturePublishAt?: number,
      includeExternalUrl?: number,
      options?: any
    ) {
      return MangaApiFp(configuration).getMangaIdFeed(
        id,
        limit,
        offset,
        translatedLanguage,
        originalLanguage,
        excludedOriginalLanguage,
        contentRating,
        excludedGroups,
        excludedUploaders,
        includeFutureUpdates,
        createdAtSince,
        updatedAtSince,
        publishAtSince,
        orderCreatedAt,
        orderUpdatedAt,
        orderPublishAt,
        orderReadableAt,
        orderVolume,
        orderChapter,
        includes,
        includeEmptyPages,
        includeFuturePublishAt,
        includeExternalUrl,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get a Manga reading status
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaIdStatus(id: string, options?: any) {
      return MangaApiFp(configuration).getMangaIdStatus(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get a random Manga
     * @param {ReferenceExpansionManga} [includes]
     * @param {Array<string>} [contentRating]
     * @param {Array<string>} [includedTags]
     * @param {string} [includedTagsMode]
     * @param {Array<string>} [excludedTags]
     * @param {string} [excludedTagsMode]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaRandom(
      includes?: ReferenceExpansionManga,
      contentRating?: Array<string>,
      includedTags?: Array<string>,
      includedTagsMode?: string,
      excludedTags?: Array<string>,
      excludedTagsMode?: string,
      options?: any
    ) {
      return MangaApiFp(configuration).getMangaRandom(
        includes,
        contentRating,
        includedTags,
        includedTagsMode,
        excludedTags,
        excludedTagsMode,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Manga relation list
     * @param {string} mangaId
     * @param {ReferenceExpansionMangaRelation} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaRelation(
      mangaId: string,
      includes?: ReferenceExpansionMangaRelation,
      options?: any
    ) {
      return MangaApiFp(configuration).getMangaRelation(
        mangaId,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get all Manga reading status for logged User
     * @param {string} [status] Used to filter the list by given status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaStatus(status?: string, options?: any) {
      return MangaApiFp(configuration).getMangaStatus(status, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Tag list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaTag(options?: any) {
      return MangaApiFp(configuration).getMangaTag(options)(fetch, basePath)
    },
    /**
     * Search a list of Manga.
     * @summary Manga list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [title]
     * @param {string} [authorOrArtist]
     * @param {Array<string>} [authors]
     * @param {Array<string>} [artists]
     * @param {number} [year] Year of release
     * @param {Array<string>} [includedTags]
     * @param {string} [includedTagsMode]
     * @param {Array<string>} [excludedTags]
     * @param {string} [excludedTagsMode]
     * @param {Array<string>} [status]
     * @param {Array<string>} [originalLanguage]
     * @param {Array<string>} [excludedOriginalLanguage]
     * @param {Array<string>} [availableTranslatedLanguage]
     * @param {Array<string>} [publicationDemographic]
     * @param {Array<string>} [ids] Manga ids (limited to 100 per request)
     * @param {Array<string>} [contentRating]
     * @param {string} [createdAtSince]
     * @param {string} [updatedAtSince]
     * @param {string} [orderTitle]
     * @param {string} [orderYear]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderLatestUploadedChapter]
     * @param {string} [orderFollowedCount]
     * @param {string} [orderRelevance]
     * @param {string} [orderRating]
     * @param {ReferenceExpansionManga} [includes]
     * @param {string} [hasAvailableChapters]
     * @param {string} [group]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchManga(
      limit?: number,
      offset?: number,
      title?: string,
      authorOrArtist?: string,
      authors?: Array<string>,
      artists?: Array<string>,
      year?: number,
      includedTags?: Array<string>,
      includedTagsMode?: string,
      excludedTags?: Array<string>,
      excludedTagsMode?: string,
      status?: Array<string>,
      originalLanguage?: Array<string>,
      excludedOriginalLanguage?: Array<string>,
      availableTranslatedLanguage?: Array<string>,
      publicationDemographic?: Array<string>,
      ids?: Array<string>,
      contentRating?: Array<string>,
      createdAtSince?: string,
      updatedAtSince?: string,
      orderTitle?: string,
      orderYear?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderLatestUploadedChapter?: string,
      orderFollowedCount?: string,
      orderRelevance?: string,
      orderRating?: string,
      includes?: ReferenceExpansionManga,
      hasAvailableChapters?: string,
      group?: string,
      options?: any
    ) {
      return MangaApiFp(configuration).getSearchManga(
        limit,
        offset,
        title,
        authorOrArtist,
        authors,
        artists,
        year,
        includedTags,
        includedTagsMode,
        excludedTags,
        excludedTagsMode,
        status,
        originalLanguage,
        excludedOriginalLanguage,
        availableTranslatedLanguage,
        publicationDemographic,
        ids,
        contentRating,
        createdAtSince,
        updatedAtSince,
        orderTitle,
        orderYear,
        orderCreatedAt,
        orderUpdatedAt,
        orderLatestUploadedChapter,
        orderFollowedCount,
        orderRelevance,
        orderRating,
        includes,
        hasAvailableChapters,
        group,
        options
      )(fetch, basePath)
    },
    /**
     * Create a new Manga.
     * @summary Create Manga
     * @param {string} contentType
     * @param {MangaCreate} [body] The size of the body is limited to 64KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postManga(contentType: string, body?: MangaCreate, options?: any) {
      return MangaApiFp(configuration).postManga(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Follow Manga
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdFollow(id: string, options?: any) {
      return MangaApiFp(configuration).postMangaIdFollow(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Update Manga reading status
     * @param {string} id
     * @param {string} contentType
     * @param {UpdateMangaStatus} [body] Using a &#x60;null&#x60; value in &#x60;status&#x60; field will remove the Manga reading status. The size of the body is limited to 2KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaIdStatus(
      id: string,
      contentType: string,
      body?: UpdateMangaStatus,
      options?: any
    ) {
      return MangaApiFp(configuration).postMangaIdStatus(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     * Create a new Manga relation.
     * @summary Create Manga relation
     * @param {string} mangaId
     * @param {string} contentType
     * @param {MangaRelationCreate} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaRelation(
      mangaId: string,
      contentType: string,
      body?: MangaRelationCreate,
      options?: any
    ) {
      return MangaApiFp(configuration).postMangaRelation(
        mangaId,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Update Manga
     * @param {string} id Manga ID
     * @param {string} contentType
     * @param {MangaIdBody} [body] The size of the body is limited to 64KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putMangaId(
      id: string,
      contentType: string,
      body?: MangaIdBody,
      options?: any
    ) {
      return MangaApiFp(configuration).putMangaId(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * MangaApi - object-oriented interface
 * @export
 * @class MangaApi
 * @extends {BaseAPI}
 */
export class MangaApi extends BaseAPI {
  /**
   *
   * @summary Submit a Manga Draft
   * @param {string} id
   * @param {IdCommitBody} [body] A Manga Draft that is to be submitted must have at least one cover in the original language, must be in the &quot;draft&quot; state and must be passed the correct version in the request body.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public commitMangaDraft(id: string, body?: IdCommitBody, options?: any) {
    return MangaApiFp(this.configuration).commitMangaDraft(
      id,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Delete Manga
   * @param {string} id Manga ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public deleteMangaId(id: string, options?: any) {
    return MangaApiFp(this.configuration).deleteMangaId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Unfollow Manga
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public deleteMangaIdFollow(id: string, options?: any) {
    return MangaApiFp(this.configuration).deleteMangaIdFollow(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Delete Manga relation
   * @param {string} mangaId
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public deleteMangaRelationId(mangaId: string, id: string, options?: any) {
    return MangaApiFp(this.configuration).deleteMangaRelationId(
      mangaId,
      id,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get Manga volumes & chapters
   * @param {string} id Manga ID
   * @param {Array<string>} [translatedLanguage]
   * @param {Array<string>} [groups]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaAggregate(
    id: string,
    translatedLanguage?: Array<string>,
    groups?: Array<string>,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaAggregate(
      id,
      translatedLanguage,
      groups,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get a list of Manga Drafts
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [state]
   * @param {string} [orderTitle]
   * @param {string} [orderYear]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {ReferenceExpansionManga} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaDrafts(
    limit?: number,
    offset?: number,
    state?: string,
    orderTitle?: string,
    orderYear?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    includes?: ReferenceExpansionManga,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaDrafts(
      limit,
      offset,
      state,
      orderTitle,
      orderYear,
      orderCreatedAt,
      orderUpdatedAt,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Get Manga.
   * @summary Get Manga
   * @param {string} id Manga ID
   * @param {ReferenceExpansionManga} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaId(
    id: string,
    includes?: ReferenceExpansionManga,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaId(
      id,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get a specific Manga Draft
   * @param {string} id
   * @param {ReferenceExpansionManga} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaIdDraft(
    id: string,
    includes?: ReferenceExpansionManga,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaIdDraft(
      id,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Manga feed
   * @param {string} id Manga ID
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [translatedLanguage]
   * @param {Array<string>} [originalLanguage]
   * @param {Array<string>} [excludedOriginalLanguage]
   * @param {Array<string>} [contentRating]
   * @param {Array<string>} [excludedGroups]
   * @param {Array<string>} [excludedUploaders]
   * @param {string} [includeFutureUpdates]
   * @param {string} [createdAtSince]
   * @param {string} [updatedAtSince]
   * @param {string} [publishAtSince]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderPublishAt]
   * @param {string} [orderReadableAt]
   * @param {string} [orderVolume]
   * @param {string} [orderChapter]
   * @param {ReferenceExpansionChapter} [includes]
   * @param {number} [includeEmptyPages]
   * @param {number} [includeFuturePublishAt]
   * @param {number} [includeExternalUrl]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaIdFeed(
    id: string,
    limit?: number,
    offset?: number,
    translatedLanguage?: Array<string>,
    originalLanguage?: Array<string>,
    excludedOriginalLanguage?: Array<string>,
    contentRating?: Array<string>,
    excludedGroups?: Array<string>,
    excludedUploaders?: Array<string>,
    includeFutureUpdates?: string,
    createdAtSince?: string,
    updatedAtSince?: string,
    publishAtSince?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderPublishAt?: string,
    orderReadableAt?: string,
    orderVolume?: string,
    orderChapter?: string,
    includes?: ReferenceExpansionChapter,
    includeEmptyPages?: number,
    includeFuturePublishAt?: number,
    includeExternalUrl?: number,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaIdFeed(
      id,
      limit,
      offset,
      translatedLanguage,
      originalLanguage,
      excludedOriginalLanguage,
      contentRating,
      excludedGroups,
      excludedUploaders,
      includeFutureUpdates,
      createdAtSince,
      updatedAtSince,
      publishAtSince,
      orderCreatedAt,
      orderUpdatedAt,
      orderPublishAt,
      orderReadableAt,
      orderVolume,
      orderChapter,
      includes,
      includeEmptyPages,
      includeFuturePublishAt,
      includeExternalUrl,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get a Manga reading status
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaIdStatus(id: string, options?: any) {
    return MangaApiFp(this.configuration).getMangaIdStatus(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get a random Manga
   * @param {ReferenceExpansionManga} [includes]
   * @param {Array<string>} [contentRating]
   * @param {Array<string>} [includedTags]
   * @param {string} [includedTagsMode]
   * @param {Array<string>} [excludedTags]
   * @param {string} [excludedTagsMode]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaRandom(
    includes?: ReferenceExpansionManga,
    contentRating?: Array<string>,
    includedTags?: Array<string>,
    includedTagsMode?: string,
    excludedTags?: Array<string>,
    excludedTagsMode?: string,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaRandom(
      includes,
      contentRating,
      includedTags,
      includedTagsMode,
      excludedTags,
      excludedTagsMode,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Manga relation list
   * @param {string} mangaId
   * @param {ReferenceExpansionMangaRelation} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaRelation(
    mangaId: string,
    includes?: ReferenceExpansionMangaRelation,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getMangaRelation(
      mangaId,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get all Manga reading status for logged User
   * @param {string} [status] Used to filter the list by given status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaStatus(status?: string, options?: any) {
    return MangaApiFp(this.configuration).getMangaStatus(status, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Tag list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getMangaTag(options?: any) {
    return MangaApiFp(this.configuration).getMangaTag(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Search a list of Manga.
   * @summary Manga list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [title]
   * @param {string} [authorOrArtist]
   * @param {Array<string>} [authors]
   * @param {Array<string>} [artists]
   * @param {number} [year] Year of release
   * @param {Array<string>} [includedTags]
   * @param {string} [includedTagsMode]
   * @param {Array<string>} [excludedTags]
   * @param {string} [excludedTagsMode]
   * @param {Array<string>} [status]
   * @param {Array<string>} [originalLanguage]
   * @param {Array<string>} [excludedOriginalLanguage]
   * @param {Array<string>} [availableTranslatedLanguage]
   * @param {Array<string>} [publicationDemographic]
   * @param {Array<string>} [ids] Manga ids (limited to 100 per request)
   * @param {Array<string>} [contentRating]
   * @param {string} [createdAtSince]
   * @param {string} [updatedAtSince]
   * @param {string} [orderTitle]
   * @param {string} [orderYear]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderLatestUploadedChapter]
   * @param {string} [orderFollowedCount]
   * @param {string} [orderRelevance]
   * @param {string} [orderRating]
   * @param {ReferenceExpansionManga} [includes]
   * @param {string} [hasAvailableChapters]
   * @param {string} [group]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public getSearchManga(
    limit?: number,
    offset?: number,
    title?: string,
    authorOrArtist?: string,
    authors?: Array<string>,
    artists?: Array<string>,
    year?: number,
    includedTags?: Array<string>,
    includedTagsMode?: string,
    excludedTags?: Array<string>,
    excludedTagsMode?: string,
    status?: Array<string>,
    originalLanguage?: Array<string>,
    excludedOriginalLanguage?: Array<string>,
    availableTranslatedLanguage?: Array<string>,
    publicationDemographic?: Array<string>,
    ids?: Array<string>,
    contentRating?: Array<string>,
    createdAtSince?: string,
    updatedAtSince?: string,
    orderTitle?: string,
    orderYear?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderLatestUploadedChapter?: string,
    orderFollowedCount?: string,
    orderRelevance?: string,
    orderRating?: string,
    includes?: ReferenceExpansionManga,
    hasAvailableChapters?: string,
    group?: string,
    options?: any
  ) {
    return MangaApiFp(this.configuration).getSearchManga(
      limit,
      offset,
      title,
      authorOrArtist,
      authors,
      artists,
      year,
      includedTags,
      includedTagsMode,
      excludedTags,
      excludedTagsMode,
      status,
      originalLanguage,
      excludedOriginalLanguage,
      availableTranslatedLanguage,
      publicationDemographic,
      ids,
      contentRating,
      createdAtSince,
      updatedAtSince,
      orderTitle,
      orderYear,
      orderCreatedAt,
      orderUpdatedAt,
      orderLatestUploadedChapter,
      orderFollowedCount,
      orderRelevance,
      orderRating,
      includes,
      hasAvailableChapters,
      group,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Create a new Manga.
   * @summary Create Manga
   * @param {string} contentType
   * @param {MangaCreate} [body] The size of the body is limited to 64KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public postManga(contentType: string, body?: MangaCreate, options?: any) {
    return MangaApiFp(this.configuration).postManga(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Follow Manga
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public postMangaIdFollow(id: string, options?: any) {
    return MangaApiFp(this.configuration).postMangaIdFollow(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Update Manga reading status
   * @param {string} id
   * @param {string} contentType
   * @param {UpdateMangaStatus} [body] Using a &#x60;null&#x60; value in &#x60;status&#x60; field will remove the Manga reading status. The size of the body is limited to 2KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public postMangaIdStatus(
    id: string,
    contentType: string,
    body?: UpdateMangaStatus,
    options?: any
  ) {
    return MangaApiFp(this.configuration).postMangaIdStatus(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * Create a new Manga relation.
   * @summary Create Manga relation
   * @param {string} mangaId
   * @param {string} contentType
   * @param {MangaRelationCreate} [body] The size of the body is limited to 8KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public postMangaRelation(
    mangaId: string,
    contentType: string,
    body?: MangaRelationCreate,
    options?: any
  ) {
    return MangaApiFp(this.configuration).postMangaRelation(
      mangaId,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Update Manga
   * @param {string} id Manga ID
   * @param {string} contentType
   * @param {MangaIdBody} [body] The size of the body is limited to 64KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MangaApi
   */
  public putMangaId(
    id: string,
    contentType: string,
    body?: MangaIdBody,
    options?: any
  ) {
    return MangaApiFp(this.configuration).putMangaId(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * RatingApi - fetch parameter creator
 * @export
 */
export const RatingApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete Manga rating
     * @param {string} mangaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRatingMangaId(mangaId: string, options: any = {}): FetchArgs {
      // verify required parameter 'mangaId' is not null or undefined
      if (mangaId === null || mangaId === undefined) {
        throw new RequiredError(
          'mangaId',
          'Required parameter mangaId was null or undefined when calling deleteRatingMangaId.'
        )
      }
      const localVarPath = `/rating/{mangaId}`.replace(
        `{${'mangaId'}}`,
        encodeURIComponent(String(mangaId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get your ratings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRating(options: any = {}): FetchArgs {
      const localVarPath = `/rating`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create or update Manga rating
     * @param {string} mangaId
     * @param {RatingMangaIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRatingMangaId(
      mangaId: string,
      body?: RatingMangaIdBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'mangaId' is not null or undefined
      if (mangaId === null || mangaId === undefined) {
        throw new RequiredError(
          'mangaId',
          'Required parameter mangaId was null or undefined when calling postRatingMangaId.'
        )
      }
      const localVarPath = `/rating/{mangaId}`.replace(
        `{${'mangaId'}}`,
        encodeURIComponent(String(mangaId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'RatingMangaIdBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * RatingApi - functional programming interface
 * @export
 */
export const RatingApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete Manga rating
     * @param {string} mangaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRatingMangaId(
      mangaId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RatingApiFetchParamCreator(
        configuration
      ).deleteRatingMangaId(mangaId, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get your ratings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRating(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20011> {
      const localVarFetchArgs =
        RatingApiFetchParamCreator(configuration).getRating(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create or update Manga rating
     * @param {string} mangaId
     * @param {RatingMangaIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRatingMangaId(
      mangaId: string,
      body?: RatingMangaIdBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = RatingApiFetchParamCreator(
        configuration
      ).postRatingMangaId(mangaId, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * RatingApi - factory interface
 * @export
 */
export const RatingApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete Manga rating
     * @param {string} mangaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRatingMangaId(mangaId: string, options?: any) {
      return RatingApiFp(configuration).deleteRatingMangaId(mangaId, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get your ratings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRating(options?: any) {
      return RatingApiFp(configuration).getRating(options)(fetch, basePath)
    },
    /**
     *
     * @summary Create or update Manga rating
     * @param {string} mangaId
     * @param {RatingMangaIdBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postRatingMangaId(
      mangaId: string,
      body?: RatingMangaIdBody,
      options?: any
    ) {
      return RatingApiFp(configuration).postRatingMangaId(
        mangaId,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * RatingApi - object-oriented interface
 * @export
 * @class RatingApi
 * @extends {BaseAPI}
 */
export class RatingApi extends BaseAPI {
  /**
   *
   * @summary Delete Manga rating
   * @param {string} mangaId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatingApi
   */
  public deleteRatingMangaId(mangaId: string, options?: any) {
    return RatingApiFp(this.configuration).deleteRatingMangaId(
      mangaId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get your ratings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatingApi
   */
  public getRating(options?: any) {
    return RatingApiFp(this.configuration).getRating(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Create or update Manga rating
   * @param {string} mangaId
   * @param {RatingMangaIdBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RatingApi
   */
  public postRatingMangaId(
    mangaId: string,
    body?: RatingMangaIdBody,
    options?: any
  ) {
    return RatingApiFp(this.configuration).postRatingMangaId(
      mangaId,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * ReadMarkerApi - fetch parameter creator
 * @export
 */
export const ReadMarkerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * A list of chapter ids that are marked as read for the specified manga
     * @summary Manga read markers
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaChapterReadmarkers(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getMangaChapterReadmarkers.'
        )
      }
      const localVarPath = `/manga/{id}/read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * A list of chapter ids that are marked as read for the given manga ids
     * @summary Manga read markers
     * @param {Array<string>} ids Manga ids
     * @param {boolean} [grouped] Group results by manga ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaChapterReadmarkers2(
      ids: Array<string>,
      grouped?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'ids' is not null or undefined
      if (ids === null || ids === undefined) {
        throw new RequiredError(
          'ids',
          'Required parameter ids was null or undefined when calling getMangaChapterReadmarkers2.'
        )
      }
      const localVarPath = `/manga/read`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (grouped !== undefined) {
        localVarQueryParameter['grouped'] = grouped
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get users reading history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadingHistory(options: any = {}): FetchArgs {
      const localVarPath = `/user/history`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     * Send a lot of chapter ids for one manga to mark as read and/or unread
     * @summary Manga read markers batch
     * @param {string} id
     * @param {ChapterReadMarkerBatch} [body] The size of the body is limited to 10KB.
     * @param {boolean} [updateHistory] Adding this will cause the chapter to be stored in the user&#x27;s reading history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaChapterReadmarkers(
      id: string,
      body?: ChapterReadMarkerBatch,
      updateHistory?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postMangaChapterReadmarkers.'
        )
      }
      const localVarPath = `/manga/{id}/read`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (updateHistory !== undefined) {
        localVarQueryParameter['updateHistory'] = updateHistory
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'ChapterReadMarkerBatch' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ReadMarkerApi - functional programming interface
 * @export
 */
export const ReadMarkerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * A list of chapter ids that are marked as read for the specified manga
     * @summary Manga read markers
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaChapterReadmarkers(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
      const localVarFetchArgs = ReadMarkerApiFetchParamCreator(
        configuration
      ).getMangaChapterReadmarkers(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * A list of chapter ids that are marked as read for the given manga ids
     * @summary Manga read markers
     * @param {Array<string>} ids Manga ids
     * @param {boolean} [grouped] Group results by manga ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaChapterReadmarkers2(
      ids: Array<string>,
      grouped?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
      const localVarFetchArgs = ReadMarkerApiFetchParamCreator(
        configuration
      ).getMangaChapterReadmarkers2(ids, grouped, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get users reading history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadingHistory(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20017> {
      const localVarFetchArgs =
        ReadMarkerApiFetchParamCreator(configuration).getReadingHistory(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     * Send a lot of chapter ids for one manga to mark as read and/or unread
     * @summary Manga read markers batch
     * @param {string} id
     * @param {ChapterReadMarkerBatch} [body] The size of the body is limited to 10KB.
     * @param {boolean} [updateHistory] Adding this will cause the chapter to be stored in the user&#x27;s reading history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaChapterReadmarkers(
      id: string,
      body?: ChapterReadMarkerBatch,
      updateHistory?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
      const localVarFetchArgs = ReadMarkerApiFetchParamCreator(
        configuration
      ).postMangaChapterReadmarkers(id, body, updateHistory, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * ReadMarkerApi - factory interface
 * @export
 */
export const ReadMarkerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * A list of chapter ids that are marked as read for the specified manga
     * @summary Manga read markers
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaChapterReadmarkers(id: string, options?: any) {
      return ReadMarkerApiFp(configuration).getMangaChapterReadmarkers(
        id,
        options
      )(fetch, basePath)
    },
    /**
     * A list of chapter ids that are marked as read for the given manga ids
     * @summary Manga read markers
     * @param {Array<string>} ids Manga ids
     * @param {boolean} [grouped] Group results by manga ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMangaChapterReadmarkers2(
      ids: Array<string>,
      grouped?: boolean,
      options?: any
    ) {
      return ReadMarkerApiFp(configuration).getMangaChapterReadmarkers2(
        ids,
        grouped,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get users reading history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReadingHistory(options?: any) {
      return ReadMarkerApiFp(configuration).getReadingHistory(options)(
        fetch,
        basePath
      )
    },
    /**
     * Send a lot of chapter ids for one manga to mark as read and/or unread
     * @summary Manga read markers batch
     * @param {string} id
     * @param {ChapterReadMarkerBatch} [body] The size of the body is limited to 10KB.
     * @param {boolean} [updateHistory] Adding this will cause the chapter to be stored in the user&#x27;s reading history
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postMangaChapterReadmarkers(
      id: string,
      body?: ChapterReadMarkerBatch,
      updateHistory?: boolean,
      options?: any
    ) {
      return ReadMarkerApiFp(configuration).postMangaChapterReadmarkers(
        id,
        body,
        updateHistory,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * ReadMarkerApi - object-oriented interface
 * @export
 * @class ReadMarkerApi
 * @extends {BaseAPI}
 */
export class ReadMarkerApi extends BaseAPI {
  /**
   * A list of chapter ids that are marked as read for the specified manga
   * @summary Manga read markers
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadMarkerApi
   */
  public getMangaChapterReadmarkers(id: string, options?: any) {
    return ReadMarkerApiFp(this.configuration).getMangaChapterReadmarkers(
      id,
      options
    )(this.fetch, this.basePath)
  }

  /**
   * A list of chapter ids that are marked as read for the given manga ids
   * @summary Manga read markers
   * @param {Array<string>} ids Manga ids
   * @param {boolean} [grouped] Group results by manga ids
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadMarkerApi
   */
  public getMangaChapterReadmarkers2(
    ids: Array<string>,
    grouped?: boolean,
    options?: any
  ) {
    return ReadMarkerApiFp(this.configuration).getMangaChapterReadmarkers2(
      ids,
      grouped,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get users reading history
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadMarkerApi
   */
  public getReadingHistory(options?: any) {
    return ReadMarkerApiFp(this.configuration).getReadingHistory(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   * Send a lot of chapter ids for one manga to mark as read and/or unread
   * @summary Manga read markers batch
   * @param {string} id
   * @param {ChapterReadMarkerBatch} [body] The size of the body is limited to 10KB.
   * @param {boolean} [updateHistory] Adding this will cause the chapter to be stored in the user&#x27;s reading history
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadMarkerApi
   */
  public postMangaChapterReadmarkers(
    id: string,
    body?: ChapterReadMarkerBatch,
    updateHistory?: boolean,
    options?: any
  ) {
    return ReadMarkerApiFp(this.configuration).postMangaChapterReadmarkers(
      id,
      body,
      updateHistory,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * ReportApi - fetch parameter creator
 * @export
 */
export const ReportApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get a list of report reasons
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportReasonsByCategory(category: string, options: any = {}): FetchArgs {
      // verify required parameter 'category' is not null or undefined
      if (category === null || category === undefined) {
        throw new RequiredError(
          'category',
          'Required parameter category was null or undefined when calling getReportReasonsByCategory.'
        )
      }
      const localVarPath = `/report/reasons/{category}`.replace(
        `{${'category'}}`,
        encodeURIComponent(String(category))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get a list of reports by the user
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [category]
     * @param {string} [reasonId]
     * @param {string} [objectId]
     * @param {string} [status]
     * @param {string} [orderCreatedAt]
     * @param {ReferenceExpansionReport} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReports(
      limit?: number,
      offset?: number,
      category?: string,
      reasonId?: string,
      objectId?: string,
      status?: string,
      orderCreatedAt?: string,
      includes?: ReferenceExpansionReport,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/report`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (category !== undefined) {
        localVarQueryParameter['category'] = category
      }

      if (reasonId !== undefined) {
        localVarQueryParameter['reasonId'] = reasonId
      }

      if (objectId !== undefined) {
        localVarQueryParameter['objectId'] = objectId
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create a new Report
     * @param {string} contentType
     * @param {ReportBody} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postReport(
      contentType: string,
      body?: ReportBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postReport.'
        )
      }
      const localVarPath = `/report`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'ReportBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a list of report reasons
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportReasonsByCategory(
      category: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2009> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getReportReasonsByCategory(category, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get a list of reports by the user
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [category]
     * @param {string} [reasonId]
     * @param {string} [objectId]
     * @param {string} [status]
     * @param {string} [orderCreatedAt]
     * @param {ReferenceExpansionReport} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReports(
      limit?: number,
      offset?: number,
      category?: string,
      reasonId?: string,
      objectId?: string,
      status?: string,
      orderCreatedAt?: string,
      includes?: ReferenceExpansionReport,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ReportListResponse> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).getReports(
        limit,
        offset,
        category,
        reasonId,
        objectId,
        status,
        orderCreatedAt,
        includes,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create a new Report
     * @param {string} contentType
     * @param {ReportBody} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postReport(
      contentType: string,
      body?: ReportBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ReportApiFetchParamCreator(
        configuration
      ).postReport(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get a list of report reasons
     * @param {string} category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportReasonsByCategory(category: string, options?: any) {
      return ReportApiFp(configuration).getReportReasonsByCategory(
        category,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get a list of reports by the user
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {string} [category]
     * @param {string} [reasonId]
     * @param {string} [objectId]
     * @param {string} [status]
     * @param {string} [orderCreatedAt]
     * @param {ReferenceExpansionReport} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReports(
      limit?: number,
      offset?: number,
      category?: string,
      reasonId?: string,
      objectId?: string,
      status?: string,
      orderCreatedAt?: string,
      includes?: ReferenceExpansionReport,
      options?: any
    ) {
      return ReportApiFp(configuration).getReports(
        limit,
        offset,
        category,
        reasonId,
        objectId,
        status,
        orderCreatedAt,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Create a new Report
     * @param {string} contentType
     * @param {ReportBody} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postReport(contentType: string, body?: ReportBody, options?: any) {
      return ReportApiFp(configuration).postReport(
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
  /**
   *
   * @summary Get a list of report reasons
   * @param {string} category
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getReportReasonsByCategory(category: string, options?: any) {
    return ReportApiFp(this.configuration).getReportReasonsByCategory(
      category,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get a list of reports by the user
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {string} [category]
   * @param {string} [reasonId]
   * @param {string} [objectId]
   * @param {string} [status]
   * @param {string} [orderCreatedAt]
   * @param {ReferenceExpansionReport} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public getReports(
    limit?: number,
    offset?: number,
    category?: string,
    reasonId?: string,
    objectId?: string,
    status?: string,
    orderCreatedAt?: string,
    includes?: ReferenceExpansionReport,
    options?: any
  ) {
    return ReportApiFp(this.configuration).getReports(
      limit,
      offset,
      category,
      reasonId,
      objectId,
      status,
      orderCreatedAt,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Create a new Report
   * @param {string} contentType
   * @param {ReportBody} [body] The size of the body is limited to 8KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReportApi
   */
  public postReport(contentType: string, body?: ReportBody, options?: any) {
    return ReportApiFp(this.configuration).postReport(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * ScanlationGroupApi - fetch parameter creator
 * @export
 */
export const ScanlationGroupApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteGroupId.'
        )
      }
      const localVarPath = `/group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Unfollow Scanlation Group
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupIdFollow(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteGroupIdFollow.'
        )
      }
      const localVarPath = `/group/{id}/follow`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupId(
      id: string,
      includes?: ReferenceExpansionScanlationGroup,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getGroupId.'
        )
      }
      const localVarPath = `/group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Scanlation Group list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] ScanlationGroup ids (limited to 100 per request)
     * @param {string} [name]
     * @param {string} [focusedLanguage]
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {string} [orderName]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderFollowedCount]
     * @param {string} [orderRelevance]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchGroup(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      name?: string,
      focusedLanguage?: string,
      includes?: ReferenceExpansionScanlationGroup,
      orderName?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderFollowedCount?: string,
      orderRelevance?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/group`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (focusedLanguage !== undefined) {
        localVarQueryParameter['focusedLanguage'] = focusedLanguage
      }

      if (includes !== undefined) {
        localVarQueryParameter['includes[]'] = includes
      }

      if (orderName !== undefined) {
        localVarQueryParameter['order[name]'] = orderName
      }

      if (orderCreatedAt !== undefined) {
        localVarQueryParameter['order[createdAt]'] = orderCreatedAt
      }

      if (orderUpdatedAt !== undefined) {
        localVarQueryParameter['order[updatedAt]'] = orderUpdatedAt
      }

      if (orderFollowedCount !== undefined) {
        localVarQueryParameter['order[followedCount]'] = orderFollowedCount
      }

      if (orderRelevance !== undefined) {
        localVarQueryParameter['order[relevance]'] = orderRelevance
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create Scanlation Group
     * @param {string} contentType
     * @param {CreateScanlationGroup} [body] The size of the body is limited to 16KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGroup(
      contentType: string,
      body?: CreateScanlationGroup,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postGroup.'
        )
      }
      const localVarPath = `/group`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CreateScanlationGroup' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Follow Scanlation Group
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGroupIdFollow(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling postGroupIdFollow.'
        )
      }
      const localVarPath = `/group/{id}/follow`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {string} contentType
     * @param {ScanlationGroupEdit} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGroupId(
      id: string,
      contentType: string,
      body?: ScanlationGroupEdit,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling putGroupId.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling putGroupId.'
        )
      }
      const localVarPath = `/group/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'ScanlationGroupEdit' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * ScanlationGroupApi - functional programming interface
 * @export
 */
export const ScanlationGroupApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).deleteGroupId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Unfollow Scanlation Group
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupIdFollow(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).deleteGroupIdFollow(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupId(
      id: string,
      includes?: ReferenceExpansionScanlationGroup,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ScanlationGroupResponse> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).getGroupId(id, includes, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Scanlation Group list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] ScanlationGroup ids (limited to 100 per request)
     * @param {string} [name]
     * @param {string} [focusedLanguage]
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {string} [orderName]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderFollowedCount]
     * @param {string} [orderRelevance]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchGroup(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      name?: string,
      focusedLanguage?: string,
      includes?: ReferenceExpansionScanlationGroup,
      orderName?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderFollowedCount?: string,
      orderRelevance?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ScanlationGroupList> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).getSearchGroup(
        limit,
        offset,
        ids,
        name,
        focusedLanguage,
        includes,
        orderName,
        orderCreatedAt,
        orderUpdatedAt,
        orderFollowedCount,
        orderRelevance,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create Scanlation Group
     * @param {string} contentType
     * @param {CreateScanlationGroup} [body] The size of the body is limited to 16KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGroup(
      contentType: string,
      body?: CreateScanlationGroup,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ScanlationGroupResponse> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).postGroup(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Follow Scanlation Group
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGroupIdFollow(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).postGroupIdFollow(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {string} contentType
     * @param {ScanlationGroupEdit} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGroupId(
      id: string,
      contentType: string,
      body?: ScanlationGroupEdit,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ScanlationGroupResponse> {
      const localVarFetchArgs = ScanlationGroupApiFetchParamCreator(
        configuration
      ).putGroupId(id, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * ScanlationGroupApi - factory interface
 * @export
 */
export const ScanlationGroupApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupId(id: string, options?: any) {
      return ScanlationGroupApiFp(configuration).deleteGroupId(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Unfollow Scanlation Group
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteGroupIdFollow(id: string, options?: any) {
      return ScanlationGroupApiFp(configuration).deleteGroupIdFollow(
        id,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getGroupId(
      id: string,
      includes?: ReferenceExpansionScanlationGroup,
      options?: any
    ) {
      return ScanlationGroupApiFp(configuration).getGroupId(
        id,
        includes,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Scanlation Group list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] ScanlationGroup ids (limited to 100 per request)
     * @param {string} [name]
     * @param {string} [focusedLanguage]
     * @param {ReferenceExpansionScanlationGroup} [includes]
     * @param {string} [orderName]
     * @param {string} [orderCreatedAt]
     * @param {string} [orderUpdatedAt]
     * @param {string} [orderFollowedCount]
     * @param {string} [orderRelevance]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSearchGroup(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      name?: string,
      focusedLanguage?: string,
      includes?: ReferenceExpansionScanlationGroup,
      orderName?: string,
      orderCreatedAt?: string,
      orderUpdatedAt?: string,
      orderFollowedCount?: string,
      orderRelevance?: string,
      options?: any
    ) {
      return ScanlationGroupApiFp(configuration).getSearchGroup(
        limit,
        offset,
        ids,
        name,
        focusedLanguage,
        includes,
        orderName,
        orderCreatedAt,
        orderUpdatedAt,
        orderFollowedCount,
        orderRelevance,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Create Scanlation Group
     * @param {string} contentType
     * @param {CreateScanlationGroup} [body] The size of the body is limited to 16KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGroup(
      contentType: string,
      body?: CreateScanlationGroup,
      options?: any
    ) {
      return ScanlationGroupApiFp(configuration).postGroup(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Follow Scanlation Group
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postGroupIdFollow(id: string, options?: any) {
      return ScanlationGroupApiFp(configuration).postGroupIdFollow(id, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Update Scanlation Group
     * @param {string} id Scanlation Group ID
     * @param {string} contentType
     * @param {ScanlationGroupEdit} [body] The size of the body is limited to 8KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putGroupId(
      id: string,
      contentType: string,
      body?: ScanlationGroupEdit,
      options?: any
    ) {
      return ScanlationGroupApiFp(configuration).putGroupId(
        id,
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * ScanlationGroupApi - object-oriented interface
 * @export
 * @class ScanlationGroupApi
 * @extends {BaseAPI}
 */
export class ScanlationGroupApi extends BaseAPI {
  /**
   *
   * @summary Delete Scanlation Group
   * @param {string} id Scanlation Group ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public deleteGroupId(id: string, options?: any) {
    return ScanlationGroupApiFp(this.configuration).deleteGroupId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Unfollow Scanlation Group
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public deleteGroupIdFollow(id: string, options?: any) {
    return ScanlationGroupApiFp(this.configuration).deleteGroupIdFollow(
      id,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get Scanlation Group
   * @param {string} id Scanlation Group ID
   * @param {ReferenceExpansionScanlationGroup} [includes]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public getGroupId(
    id: string,
    includes?: ReferenceExpansionScanlationGroup,
    options?: any
  ) {
    return ScanlationGroupApiFp(this.configuration).getGroupId(
      id,
      includes,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Scanlation Group list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [ids] ScanlationGroup ids (limited to 100 per request)
   * @param {string} [name]
   * @param {string} [focusedLanguage]
   * @param {ReferenceExpansionScanlationGroup} [includes]
   * @param {string} [orderName]
   * @param {string} [orderCreatedAt]
   * @param {string} [orderUpdatedAt]
   * @param {string} [orderFollowedCount]
   * @param {string} [orderRelevance]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public getSearchGroup(
    limit?: number,
    offset?: number,
    ids?: Array<string>,
    name?: string,
    focusedLanguage?: string,
    includes?: ReferenceExpansionScanlationGroup,
    orderName?: string,
    orderCreatedAt?: string,
    orderUpdatedAt?: string,
    orderFollowedCount?: string,
    orderRelevance?: string,
    options?: any
  ) {
    return ScanlationGroupApiFp(this.configuration).getSearchGroup(
      limit,
      offset,
      ids,
      name,
      focusedLanguage,
      includes,
      orderName,
      orderCreatedAt,
      orderUpdatedAt,
      orderFollowedCount,
      orderRelevance,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Create Scanlation Group
   * @param {string} contentType
   * @param {CreateScanlationGroup} [body] The size of the body is limited to 16KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public postGroup(
    contentType: string,
    body?: CreateScanlationGroup,
    options?: any
  ) {
    return ScanlationGroupApiFp(this.configuration).postGroup(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Follow Scanlation Group
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public postGroupIdFollow(id: string, options?: any) {
    return ScanlationGroupApiFp(this.configuration).postGroupIdFollow(
      id,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Update Scanlation Group
   * @param {string} id Scanlation Group ID
   * @param {string} contentType
   * @param {ScanlationGroupEdit} [body] The size of the body is limited to 8KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScanlationGroupApi
   */
  public putGroupId(
    id: string,
    contentType: string,
    body?: ScanlationGroupEdit,
    options?: any
  ) {
    return ScanlationGroupApiFp(this.configuration).putGroupId(
      id,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * SettingsApi - fetch parameter creator
 * @export
 */
export const SettingsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get an User Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(options: any = {}): FetchArgs {
      const localVarPath = `/settings`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get latest Settings template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsTemplate(options: any = {}): FetchArgs {
      const localVarPath = `/settings/template`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get Settings template by version id
     * @param {string} version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsTemplateVersion(version: string, options: any = {}): FetchArgs {
      // verify required parameter 'version' is not null or undefined
      if (version === null || version === undefined) {
        throw new RequiredError(
          'version',
          'Required parameter version was null or undefined when calling getSettingsTemplateVersion.'
        )
      }
      const localVarPath = `/settings/template/{version}`.replace(
        `{${'version'}}`,
        encodeURIComponent(String(version))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create or update an User Settings
     * @param {SettingsBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSettings(body?: SettingsBody, options: any = {}): FetchArgs {
      const localVarPath = `/settings`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'SettingsBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Create Settings template
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSettingsTemplate(body?: any, options: any = {}): FetchArgs {
      const localVarPath = `/settings/template`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'any' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get an User Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20015> {
      const localVarFetchArgs =
        SettingsApiFetchParamCreator(configuration).getSettings(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get latest Settings template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsTemplate(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs =
        SettingsApiFetchParamCreator(configuration).getSettingsTemplate(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get Settings template by version id
     * @param {string} version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsTemplateVersion(
      version: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SettingsApiFetchParamCreator(
        configuration
      ).getSettingsTemplateVersion(version, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create or update an User Settings
     * @param {SettingsBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSettings(
      body?: SettingsBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20016> {
      const localVarFetchArgs = SettingsApiFetchParamCreator(
        configuration
      ).postSettings(body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Create Settings template
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSettingsTemplate(
      body?: any,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = SettingsApiFetchParamCreator(
        configuration
      ).postSettingsTemplate(body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get an User Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettings(options?: any) {
      return SettingsApiFp(configuration).getSettings(options)(fetch, basePath)
    },
    /**
     *
     * @summary Get latest Settings template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsTemplate(options?: any) {
      return SettingsApiFp(configuration).getSettingsTemplate(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get Settings template by version id
     * @param {string} version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSettingsTemplateVersion(version: string, options?: any) {
      return SettingsApiFp(configuration).getSettingsTemplateVersion(
        version,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Create or update an User Settings
     * @param {SettingsBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSettings(body?: SettingsBody, options?: any) {
      return SettingsApiFp(configuration).postSettings(body, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Create Settings template
     * @param {any} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postSettingsTemplate(body?: any, options?: any) {
      return SettingsApiFp(configuration).postSettingsTemplate(body, options)(
        fetch,
        basePath
      )
    }
  }
}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   *
   * @summary Get an User Settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public getSettings(options?: any) {
    return SettingsApiFp(this.configuration).getSettings(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get latest Settings template
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public getSettingsTemplate(options?: any) {
    return SettingsApiFp(this.configuration).getSettingsTemplate(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get Settings template by version id
   * @param {string} version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public getSettingsTemplateVersion(version: string, options?: any) {
    return SettingsApiFp(this.configuration).getSettingsTemplateVersion(
      version,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Create or update an User Settings
   * @param {SettingsBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public postSettings(body?: SettingsBody, options?: any) {
    return SettingsApiFp(this.configuration).postSettings(body, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Create Settings template
   * @param {any} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public postSettingsTemplate(body?: any, options?: any) {
    return SettingsApiFp(this.configuration).postSettingsTemplate(
      body,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * StatisticsApi - fetch parameter creator
 * @export
 */
export const StatisticsApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get statistics about given chapter
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsChapterUuid(uuid: string, options: any = {}): FetchArgs {
      // verify required parameter 'uuid' is not null or undefined
      if (uuid === null || uuid === undefined) {
        throw new RequiredError(
          'uuid',
          'Required parameter uuid was null or undefined when calling getStatisticsChapterUuid.'
        )
      }
      const localVarPath = `/statistics/chapter/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get statistics about given chapters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsChapters(options: any = {}): FetchArgs {
      const localVarPath = `/statistics/chapter`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get statistics about given scanlation group
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsGroupUuid(uuid: string, options: any = {}): FetchArgs {
      // verify required parameter 'uuid' is not null or undefined
      if (uuid === null || uuid === undefined) {
        throw new RequiredError(
          'uuid',
          'Required parameter uuid was null or undefined when calling getStatisticsGroupUuid.'
        )
      }
      const localVarPath = `/statistics/group/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get statistics about given groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsGroups(options: any = {}): FetchArgs {
      const localVarPath = `/statistics/group`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Find statistics about given Manga
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsManga(options: any = {}): FetchArgs {
      const localVarPath = `/statistics/manga`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get statistics about given Manga
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsMangaUuid(uuid: string, options: any = {}): FetchArgs {
      // verify required parameter 'uuid' is not null or undefined
      if (uuid === null || uuid === undefined) {
        throw new RequiredError(
          'uuid',
          'Required parameter uuid was null or undefined when calling getStatisticsMangaUuid.'
        )
      }
      const localVarPath = `/statistics/manga/{uuid}`.replace(
        `{${'uuid'}}`,
        encodeURIComponent(String(uuid))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get statistics about given chapter
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsChapterUuid(
      uuid: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
      const localVarFetchArgs = StatisticsApiFetchParamCreator(
        configuration
      ).getStatisticsChapterUuid(uuid, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get statistics about given chapters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsChapters(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
      const localVarFetchArgs =
        StatisticsApiFetchParamCreator(configuration).getStatisticsChapters(
          options
        )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get statistics about given scanlation group
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsGroupUuid(
      uuid: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
      const localVarFetchArgs = StatisticsApiFetchParamCreator(
        configuration
      ).getStatisticsGroupUuid(uuid, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get statistics about given groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsGroups(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20012> {
      const localVarFetchArgs =
        StatisticsApiFetchParamCreator(configuration).getStatisticsGroups(
          options
        )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Find statistics about given Manga
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsManga(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20014> {
      const localVarFetchArgs =
        StatisticsApiFetchParamCreator(configuration).getStatisticsManga(
          options
        )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get statistics about given Manga
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsMangaUuid(
      uuid: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20013> {
      const localVarFetchArgs = StatisticsApiFetchParamCreator(
        configuration
      ).getStatisticsMangaUuid(uuid, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Get statistics about given chapter
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsChapterUuid(uuid: string, options?: any) {
      return StatisticsApiFp(configuration).getStatisticsChapterUuid(
        uuid,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get statistics about given chapters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsChapters(options?: any) {
      return StatisticsApiFp(configuration).getStatisticsChapters(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get statistics about given scanlation group
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsGroupUuid(uuid: string, options?: any) {
      return StatisticsApiFp(configuration).getStatisticsGroupUuid(
        uuid,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get statistics about given groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsGroups(options?: any) {
      return StatisticsApiFp(configuration).getStatisticsGroups(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Find statistics about given Manga
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsManga(options?: any) {
      return StatisticsApiFp(configuration).getStatisticsManga(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Get statistics about given Manga
     * @param {string} uuid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStatisticsMangaUuid(uuid: string, options?: any) {
      return StatisticsApiFp(configuration).getStatisticsMangaUuid(
        uuid,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
  /**
   *
   * @summary Get statistics about given chapter
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsApi
   */
  public getStatisticsChapterUuid(uuid: string, options?: any) {
    return StatisticsApiFp(this.configuration).getStatisticsChapterUuid(
      uuid,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get statistics about given chapters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsApi
   */
  public getStatisticsChapters(options?: any) {
    return StatisticsApiFp(this.configuration).getStatisticsChapters(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get statistics about given scanlation group
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsApi
   */
  public getStatisticsGroupUuid(uuid: string, options?: any) {
    return StatisticsApiFp(this.configuration).getStatisticsGroupUuid(
      uuid,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get statistics about given groups
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsApi
   */
  public getStatisticsGroups(options?: any) {
    return StatisticsApiFp(this.configuration).getStatisticsGroups(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Find statistics about given Manga
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsApi
   */
  public getStatisticsManga(options?: any) {
    return StatisticsApiFp(this.configuration).getStatisticsManga(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Get statistics about given Manga
   * @param {string} uuid
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatisticsApi
   */
  public getStatisticsMangaUuid(uuid: string, options?: any) {
    return StatisticsApiFp(this.configuration).getStatisticsMangaUuid(
      uuid,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * UploadApi - fetch parameter creator
 * @export
 */
export const UploadApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Abandon upload session
     * @param {string} uploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abandonUploadSession(
      uploadSessionId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'uploadSessionId' is not null or undefined
      if (uploadSessionId === null || uploadSessionId === undefined) {
        throw new RequiredError(
          'uploadSessionId',
          'Required parameter uploadSessionId was null or undefined when calling abandonUploadSession.'
        )
      }
      const localVarPath = `/upload/{uploadSessionId}`.replace(
        `{${'uploadSessionId'}}`,
        encodeURIComponent(String(uploadSessionId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Start an edit chapter session
     * @param {string} chapterId
     * @param {string} contentType
     * @param {BeginEditSession} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    beginEditSession(
      chapterId: string,
      contentType: string,
      body?: BeginEditSession,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'chapterId' is not null or undefined
      if (chapterId === null || chapterId === undefined) {
        throw new RequiredError(
          'chapterId',
          'Required parameter chapterId was null or undefined when calling beginEditSession.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling beginEditSession.'
        )
      }
      const localVarPath = `/upload/begin/{chapterId}`.replace(
        `{${'chapterId'}}`,
        encodeURIComponent(String(chapterId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'BeginEditSession' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Start an upload session
     * @param {string} contentType
     * @param {BeginUploadSession} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    beginUploadSession(
      contentType: string,
      body?: BeginUploadSession,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling beginUploadSession.'
        )
      }
      const localVarPath = `/upload/begin`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'BeginUploadSession' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Commit the upload session and specify chapter data
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {CommitUploadSession} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitUploadSession(
      uploadSessionId: string,
      contentType: string,
      body?: CommitUploadSession,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'uploadSessionId' is not null or undefined
      if (uploadSessionId === null || uploadSessionId === undefined) {
        throw new RequiredError(
          'uploadSessionId',
          'Required parameter uploadSessionId was null or undefined when calling commitUploadSession.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling commitUploadSession.'
        )
      }
      const localVarPath = `/upload/{uploadSessionId}/commit`.replace(
        `{${'uploadSessionId'}}`,
        encodeURIComponent(String(uploadSessionId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'CommitUploadSession' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Delete an uploaded image from the Upload Session
     * @param {string} uploadSessionId
     * @param {string} uploadSessionFileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadedSessionFile(
      uploadSessionId: string,
      uploadSessionFileId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'uploadSessionId' is not null or undefined
      if (uploadSessionId === null || uploadSessionId === undefined) {
        throw new RequiredError(
          'uploadSessionId',
          'Required parameter uploadSessionId was null or undefined when calling deleteUploadedSessionFile.'
        )
      }
      // verify required parameter 'uploadSessionFileId' is not null or undefined
      if (uploadSessionFileId === null || uploadSessionFileId === undefined) {
        throw new RequiredError(
          'uploadSessionFileId',
          'Required parameter uploadSessionFileId was null or undefined when calling deleteUploadedSessionFile.'
        )
      }
      const localVarPath = `/upload/{uploadSessionId}/{uploadSessionFileId}`
        .replace(
          `{${'uploadSessionId'}}`,
          encodeURIComponent(String(uploadSessionId))
        )
        .replace(
          `{${'uploadSessionFileId'}}`,
          encodeURIComponent(String(uploadSessionFileId))
        )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Delete a set of uploaded images from the Upload Session
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {Array<string>} [body] The size of the body is limited to 20KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadedSessionFiles(
      uploadSessionId: string,
      contentType: string,
      body?: Array<string>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'uploadSessionId' is not null or undefined
      if (uploadSessionId === null || uploadSessionId === undefined) {
        throw new RequiredError(
          'uploadSessionId',
          'Required parameter uploadSessionId was null or undefined when calling deleteUploadedSessionFiles.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling deleteUploadedSessionFiles.'
        )
      }
      const localVarPath = `/upload/{uploadSessionId}/batch`.replace(
        `{${'uploadSessionId'}}`,
        encodeURIComponent(String(uploadSessionId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'Array&lt;string&gt;' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get the current User upload session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadSession(options: any = {}): FetchArgs {
      const localVarPath = `/upload`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Upload images to the upload session
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {Blob} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUploadSessionFile(
      uploadSessionId: string,
      contentType: string,
      file?: Blob,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'uploadSessionId' is not null or undefined
      if (uploadSessionId === null || uploadSessionId === undefined) {
        throw new RequiredError(
          'uploadSessionId',
          'Required parameter uploadSessionId was null or undefined when calling putUploadSessionFile.'
        )
      }
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling putUploadSessionFile.'
        )
      }
      const localVarPath = `/upload/{uploadSessionId}`.replace(
        `{${'uploadSessionId'}}`,
        encodeURIComponent(String(uploadSessionId))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new url.URLSearchParams()

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      if (file !== undefined) {
        localVarFormParams.set('file', file as any)
      }

      localVarHeaderParameter['Content-Type'] =
        'application/x-www-form-urlencoded'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      localVarRequestOptions.body = localVarFormParams.toString()

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Abandon upload session
     * @param {string} uploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abandonUploadSession(
      uploadSessionId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).abandonUploadSession(uploadSessionId, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Start an edit chapter session
     * @param {string} chapterId
     * @param {string} contentType
     * @param {BeginEditSession} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    beginEditSession(
      chapterId: string,
      contentType: string,
      body?: BeginEditSession,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSession> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).beginEditSession(chapterId, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Start an upload session
     * @param {string} contentType
     * @param {BeginUploadSession} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    beginUploadSession(
      contentType: string,
      body?: BeginUploadSession,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSession> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).beginUploadSession(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Commit the upload session and specify chapter data
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {CommitUploadSession} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitUploadSession(
      uploadSessionId: string,
      contentType: string,
      body?: CommitUploadSession,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Chapter> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).commitUploadSession(uploadSessionId, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Delete an uploaded image from the Upload Session
     * @param {string} uploadSessionId
     * @param {string} uploadSessionFileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadedSessionFile(
      uploadSessionId: string,
      uploadSessionFileId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).deleteUploadedSessionFile(uploadSessionId, uploadSessionFileId, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Delete a set of uploaded images from the Upload Session
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {Array<string>} [body] The size of the body is limited to 20KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadedSessionFiles(
      uploadSessionId: string,
      contentType: string,
      body?: Array<string>,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).deleteUploadedSessionFiles(uploadSessionId, contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get the current User upload session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadSession(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UploadSession> {
      const localVarFetchArgs =
        UploadApiFetchParamCreator(configuration).getUploadSession(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Upload images to the upload session
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {Blob} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUploadSessionFile(
      uploadSessionId: string,
      contentType: string,
      file?: Blob,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse20010> {
      const localVarFetchArgs = UploadApiFetchParamCreator(
        configuration
      ).putUploadSessionFile(uploadSessionId, contentType, file, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Abandon upload session
     * @param {string} uploadSessionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    abandonUploadSession(uploadSessionId: string, options?: any) {
      return UploadApiFp(configuration).abandonUploadSession(
        uploadSessionId,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Start an edit chapter session
     * @param {string} chapterId
     * @param {string} contentType
     * @param {BeginEditSession} [body] The size of the body is limited to 1KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    beginEditSession(
      chapterId: string,
      contentType: string,
      body?: BeginEditSession,
      options?: any
    ) {
      return UploadApiFp(configuration).beginEditSession(
        chapterId,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Start an upload session
     * @param {string} contentType
     * @param {BeginUploadSession} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    beginUploadSession(
      contentType: string,
      body?: BeginUploadSession,
      options?: any
    ) {
      return UploadApiFp(configuration).beginUploadSession(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Commit the upload session and specify chapter data
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {CommitUploadSession} [body] The size of the body is limited to 4KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitUploadSession(
      uploadSessionId: string,
      contentType: string,
      body?: CommitUploadSession,
      options?: any
    ) {
      return UploadApiFp(configuration).commitUploadSession(
        uploadSessionId,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Delete an uploaded image from the Upload Session
     * @param {string} uploadSessionId
     * @param {string} uploadSessionFileId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadedSessionFile(
      uploadSessionId: string,
      uploadSessionFileId: string,
      options?: any
    ) {
      return UploadApiFp(configuration).deleteUploadedSessionFile(
        uploadSessionId,
        uploadSessionFileId,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Delete a set of uploaded images from the Upload Session
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {Array<string>} [body] The size of the body is limited to 20KB.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUploadedSessionFiles(
      uploadSessionId: string,
      contentType: string,
      body?: Array<string>,
      options?: any
    ) {
      return UploadApiFp(configuration).deleteUploadedSessionFiles(
        uploadSessionId,
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get the current User upload session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadSession(options?: any) {
      return UploadApiFp(configuration).getUploadSession(options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Upload images to the upload session
     * @param {string} uploadSessionId
     * @param {string} contentType
     * @param {Blob} [file]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    putUploadSessionFile(
      uploadSessionId: string,
      contentType: string,
      file?: Blob,
      options?: any
    ) {
      return UploadApiFp(configuration).putUploadSessionFile(
        uploadSessionId,
        contentType,
        file,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
  /**
   *
   * @summary Abandon upload session
   * @param {string} uploadSessionId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public abandonUploadSession(uploadSessionId: string, options?: any) {
    return UploadApiFp(this.configuration).abandonUploadSession(
      uploadSessionId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Start an edit chapter session
   * @param {string} chapterId
   * @param {string} contentType
   * @param {BeginEditSession} [body] The size of the body is limited to 1KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public beginEditSession(
    chapterId: string,
    contentType: string,
    body?: BeginEditSession,
    options?: any
  ) {
    return UploadApiFp(this.configuration).beginEditSession(
      chapterId,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Start an upload session
   * @param {string} contentType
   * @param {BeginUploadSession} [body] The size of the body is limited to 4KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public beginUploadSession(
    contentType: string,
    body?: BeginUploadSession,
    options?: any
  ) {
    return UploadApiFp(this.configuration).beginUploadSession(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Commit the upload session and specify chapter data
   * @param {string} uploadSessionId
   * @param {string} contentType
   * @param {CommitUploadSession} [body] The size of the body is limited to 4KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public commitUploadSession(
    uploadSessionId: string,
    contentType: string,
    body?: CommitUploadSession,
    options?: any
  ) {
    return UploadApiFp(this.configuration).commitUploadSession(
      uploadSessionId,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Delete an uploaded image from the Upload Session
   * @param {string} uploadSessionId
   * @param {string} uploadSessionFileId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public deleteUploadedSessionFile(
    uploadSessionId: string,
    uploadSessionFileId: string,
    options?: any
  ) {
    return UploadApiFp(this.configuration).deleteUploadedSessionFile(
      uploadSessionId,
      uploadSessionFileId,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Delete a set of uploaded images from the Upload Session
   * @param {string} uploadSessionId
   * @param {string} contentType
   * @param {Array<string>} [body] The size of the body is limited to 20KB.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public deleteUploadedSessionFiles(
    uploadSessionId: string,
    contentType: string,
    body?: Array<string>,
    options?: any
  ) {
    return UploadApiFp(this.configuration).deleteUploadedSessionFiles(
      uploadSessionId,
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get the current User upload session
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public getUploadSession(options?: any) {
    return UploadApiFp(this.configuration).getUploadSession(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Upload images to the upload session
   * @param {string} uploadSessionId
   * @param {string} contentType
   * @param {Blob} [file]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UploadApi
   */
  public putUploadSessionFile(
    uploadSessionId: string,
    contentType: string,
    file?: Blob,
    options?: any
  ) {
    return UploadApiFp(this.configuration).putUploadSessionFile(
      uploadSessionId,
      contentType,
      file,
      options
    )(this.fetch, this.basePath)
  }
}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete User
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteUserId.'
        )
      }
      const localVarPath = `/user/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options
      )
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary User list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] User ids (limited to 100 per request)
     * @param {string} [username]
     * @param {string} [orderUsername]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      username?: string,
      orderUsername?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/user`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (ids) {
        localVarQueryParameter['ids[]'] = ids
      }

      if (username !== undefined) {
        localVarQueryParameter['username'] = username
      }

      if (orderUsername !== undefined) {
        localVarQueryParameter['order[username]'] = orderUsername
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Get User
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserId(id: string, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getUserId.'
        )
      }
      const localVarPath = `/user/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Logged User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMe(options: any = {}): FetchArgs {
      const localVarPath = `/user/me`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Approve User deletion
     * @param {string} code User delete code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDeleteCode(code: string, options: any = {}): FetchArgs {
      // verify required parameter 'code' is not null or undefined
      if (code === null || code === undefined) {
        throw new RequiredError(
          'code',
          'Required parameter code was null or undefined when calling postUserDeleteCode.'
        )
      }
      const localVarPath = `/user/delete/{code}`.replace(
        `{${'code'}}`,
        encodeURIComponent(String(code))
      )
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update User email
     * @param {string} contentType
     * @param {UserEmailBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEmail(
      contentType: string,
      body?: UserEmailBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postUserEmail.'
        )
      }
      const localVarPath = `/user/email`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'UserEmailBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    },
    /**
     *
     * @summary Update User password
     * @param {string} contentType
     * @param {UserPasswordBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserPassword(
      contentType: string,
      body?: UserPasswordBody,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'contentType' is not null or undefined
      if (contentType === null || contentType === undefined) {
        throw new RequiredError(
          'contentType',
          'Required parameter contentType was null or undefined when calling postUserPassword.'
        )
      }
      const localVarPath = `/user/password`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication Bearer required

      if (contentType !== undefined && contentType !== null) {
        localVarHeaderParameter['Content-Type'] = String(contentType)
      }

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      )
      const needsSerialization =
        <any>'UserPasswordBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions
      }
    }
  }
}

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete User
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).deleteUserId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary User list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] User ids (limited to 100 per request)
     * @param {string} [username]
     * @param {string} [orderUsername]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      username?: string,
      orderUsername?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserList> {
      const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(
        limit,
        offset,
        ids,
        username,
        orderUsername,
        options
      )
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Get User
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserId(
      id: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).getUserId(id, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Logged User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMe(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
      const localVarFetchArgs =
        UserApiFetchParamCreator(configuration).getUserMe(options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Approve User deletion
     * @param {string} code User delete code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDeleteCode(
      code: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).postUserDeleteCode(code, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update User email
     * @param {string} contentType
     * @param {UserEmailBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEmail(
      contentType: string,
      body?: UserEmailBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).postUserEmail(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    },
    /**
     *
     * @summary Update User password
     * @param {string} contentType
     * @param {UserPasswordBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserPassword(
      contentType: string,
      body?: UserPasswordBody,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = UserApiFetchParamCreator(
        configuration
      ).postUserPassword(contentType, body, options)
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then(response => {
          if (response.status >= 200 && response.status < 300) {
            return response.json()
          } else {
            throw response
          }
        })
      }
    }
  }
}

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @summary Delete User
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUserId(id: string, options?: any) {
      return UserApiFp(configuration).deleteUserId(id, options)(fetch, basePath)
    },
    /**
     *
     * @summary User list
     * @param {number} [limit]
     * @param {number} [offset]
     * @param {Array<string>} [ids] User ids (limited to 100 per request)
     * @param {string} [username]
     * @param {string} [orderUsername]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(
      limit?: number,
      offset?: number,
      ids?: Array<string>,
      username?: string,
      orderUsername?: string,
      options?: any
    ) {
      return UserApiFp(configuration).getUser(
        limit,
        offset,
        ids,
        username,
        orderUsername,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Get User
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserId(id: string, options?: any) {
      return UserApiFp(configuration).getUserId(id, options)(fetch, basePath)
    },
    /**
     *
     * @summary Logged User details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserMe(options?: any) {
      return UserApiFp(configuration).getUserMe(options)(fetch, basePath)
    },
    /**
     *
     * @summary Approve User deletion
     * @param {string} code User delete code
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserDeleteCode(code: string, options?: any) {
      return UserApiFp(configuration).postUserDeleteCode(code, options)(
        fetch,
        basePath
      )
    },
    /**
     *
     * @summary Update User email
     * @param {string} contentType
     * @param {UserEmailBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserEmail(contentType: string, body?: UserEmailBody, options?: any) {
      return UserApiFp(configuration).postUserEmail(
        contentType,
        body,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @summary Update User password
     * @param {string} contentType
     * @param {UserPasswordBody} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postUserPassword(
      contentType: string,
      body?: UserPasswordBody,
      options?: any
    ) {
      return UserApiFp(configuration).postUserPassword(
        contentType,
        body,
        options
      )(fetch, basePath)
    }
  }
}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *
   * @summary Delete User
   * @param {string} id User ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public deleteUserId(id: string, options?: any) {
    return UserApiFp(this.configuration).deleteUserId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary User list
   * @param {number} [limit]
   * @param {number} [offset]
   * @param {Array<string>} [ids] User ids (limited to 100 per request)
   * @param {string} [username]
   * @param {string} [orderUsername]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUser(
    limit?: number,
    offset?: number,
    ids?: Array<string>,
    username?: string,
    orderUsername?: string,
    options?: any
  ) {
    return UserApiFp(this.configuration).getUser(
      limit,
      offset,
      ids,
      username,
      orderUsername,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Get User
   * @param {string} id User ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserId(id: string, options?: any) {
    return UserApiFp(this.configuration).getUserId(id, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Logged User details
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public getUserMe(options?: any) {
    return UserApiFp(this.configuration).getUserMe(options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Approve User deletion
   * @param {string} code User delete code
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public postUserDeleteCode(code: string, options?: any) {
    return UserApiFp(this.configuration).postUserDeleteCode(code, options)(
      this.fetch,
      this.basePath
    )
  }

  /**
   *
   * @summary Update User email
   * @param {string} contentType
   * @param {UserEmailBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public postUserEmail(
    contentType: string,
    body?: UserEmailBody,
    options?: any
  ) {
    return UserApiFp(this.configuration).postUserEmail(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @summary Update User password
   * @param {string} contentType
   * @param {UserPasswordBody} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public postUserPassword(
    contentType: string,
    body?: UserPasswordBody,
    options?: any
  ) {
    return UserApiFp(this.configuration).postUserPassword(
      contentType,
      body,
      options
    )(this.fetch, this.basePath)
  }
}
